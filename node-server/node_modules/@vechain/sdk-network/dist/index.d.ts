import { TransactionClause, TransactionBody, Transaction, vechain_sdk_core_ethers, InterfaceAbi, DeployParams, FunctionFragment } from '@vechain/sdk-core';
import { AxiosError, AxiosInstance } from 'axios';
import { HTTPClientError } from '@vechain/sdk-errors';
import { EventEmitter } from 'events';

/* --- Input options start --- */

/**
 * Input options for:
 * * getAccount
 * * getBytecode
 * * getStorage
 * Methods
 */
interface AccountInputOptions {
    /**
     * (Optional) The block number or ID to reference the bytecode version.
     */
    revision?: string;
}

/* --- Input options end --- */

/* --- Responses Outputs start --- */

/**
 * The account details represent the balance, energy & whether the account is a smart contract.
 */
interface AccountDetail {
    /**
     * The balance of VET of the account.
     */
    balance: string;

    /**
     * The balance of VTHO of the account.
     */
    energy: string;

    /**
     * Whether the account is a smart contract (i.e., hasCode is true)
     */
    hasCode: boolean;
}

/**
 * The bytecode of a smart contract.
 * The bytecode is represented in hex string.
 */
interface ResponseBytecode {
    /**
     * Bytecode of the smart contract
     */
    code: string;
}

/**
 * The storage data of a smart contract at the specified position.
 * The storage data is represented in hex string.
 */
interface ResponseStorage {
    /**
     * Hex string of the storage data
     */
    value: string;
}

/* --- Responses Outputs start --- */

/**
 * Type for connected peer.
 * A connected peer is a node that is connected to the node you have specified for the thorest client.
 */
interface ConnectedPeer {
    /**
     * Name of the peer in the format of `[network]/[version]-[gitcommit]-[versionmeta]/[os]/[goversion]`.
     * e.g., `thor/v2.1.0-2b5853f-release/linux/go1.21.0`
     */
    name: string;
    /**
     * Represents the block ID of the best block of the peer.
     */
    bestBlockID: string;
    /**
     * Represents the Accumulated Witness Number (AWN) of the best block of the peer.
     */
    totalScore: number;
    /**
     * ID of the peer.
     */
    peerID: string;
    /**
     * IP address of the peer.
     */
    netAddr: string;
    /**
     * indicates whether the connection to a peer is inbound or outbound.
     * If `inbound` is true,  the peer has initiated the connection to your node. In other words, the connection request came from the peer to your VechainThor node.
     * If `inbound` is false, your node has initiated the connection to the peer. In other words, the connection request came from your VechainThor node to the peer.
     */
    inbound: boolean;
    /**
     * Duration of the connection with the peer.
     */
    duration: number;
}

/**
 * The `NodesModule` class serves as a module for node-related functionality, for example, checking the health of a node.
 */
declare class NodesModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the vechain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Retrieves connected peers of a node.
     *
     * @returns A promise that resolves to the list of connected peers.
     */
    getNodes(): Promise<ConnectedPeer | null>;
    /**
     * Checks the health of a node using the following algorithm:
     * 1. Make an HTTP GET request to retrieve the last block timestamp.
     * 2. Calculates the difference between the current time and the last block timestamp.
     * 3. If the difference is less than the tolerance, the node is healthy.
     * Note, we could also check '/node/network/peers since' but the difficulty with this approach is
     * if you consider a scenario where the node is connected to 20+ peers, which is healthy, and it receives the new blocks as expected.
     * But what if the node's disk is full, and it's not writing the new blocks to its database? In this case the node is off-sync even
     * though it's technically alive and connected
     * @returns A boolean indicating whether the node is healthy.
     * @throws {InvalidDataTypeError} - if the timestamp key does not exist in the response from the API call to the node
     * @throws {InvalidDataTypeError} - if the timestamp key exists in the response from the API call to the node but the value is not a number
     * @throws {InvalidDataTypeError} - if the response from the API call to the node is not an object
     * @throws {InvalidDataTypeError} - if the response from the API call to the node is null or undefined
     */
    isHealthy(): Promise<boolean>;
    /**
     * Extracts the timestamp from the block
     * @remarks
     * This function throws an error if the timestamp key does not exist in the response from the API call to the node
     * @param response the response from the API call to the node
     * @returns the timestamp from the block
     * @throws {InvalidDataTypeError} - if the timestamp key does not exist in the response from the API call to the node
     * @throws {InvalidDataTypeError} - if the timestamp key exists in the response from the API call to the node but the value is not a number
     * @throws {InvalidDataTypeError} - if the response from the API call to the node is not an object
     * @throws {InvalidDataTypeError} - if the response from the API call to the node is null or undefined
     */
    private readonly getTimestampFromBlock;
}

/* --- Input options start --- */

/**
 * Range interface for specifying a range of data.
 */
interface Range {
    /**
     * The unit for specifying the range (block or time).
     */
    unit?: 'block' | 'time'; // The unit for specifying the range (block or time).

    /**
     * The starting point of the range.
     */
    from?: number;

    /**
     * The ending point of the range.
     */
    to?: number;
}

/**
 * Options interface for specifying Pagination Options (offset and limits).
 */
interface PaginationOptions {
    /**
     * Offset for pagination.
     */
    offset?: number;

    /**
     * Limit for the number of results to return.
     */
    limit?: number;
}

/**
 * EventCriteria interface for filtering event logs.
 */
interface EventCriteria {
    /**
     * Address filter for event criteria.
     */
    address?: string;
    /**
     * Event topics filter.
     */
    topic0?: string;
    topic1?: string;
    topic2?: string;
    topic3?: string;
    topic4?: string;
}

/**
 * Order interface for filtering event logs.
 */
type EventDisplayOrder = 'asc' | 'desc';

/**
 * FilterEventLogsArg interface for filtering event logs.
 */
interface FilterEventLogsOptions {
    /**
     * Block range
     */
    range?: Range;
    /**
     * Pagination options
     */
    options?: PaginationOptions;
    /**
     * Event filters
     */
    criteriaSet?: EventCriteria[];
    /**
     * Sorting order
     */
    order?: EventDisplayOrder;
}

/**
 * FilterTransferLogsArg interface for filtering transfer logs.
 */
interface FilterTransferLogsOptions {
    /**
     * Block range to query
     */
    range?: Range;
    /**
     * Pagination options
     */
    options?: PaginationOptions;
    /**
     * Criteria to filter transfers by
     */
    criteriaSet: TransferCriteria[];
    /**
     * Ordering of results
     */
    order: EventDisplayOrder;
}

/* --- Input options end --- */

/* --- Responses Outputs start --- */

/**
 * Event metadata for an entity.
 */
interface Metadata {
    /**
     * Block identifier associated with the entity
     */
    blockID: string;
    /**
     * Block number associated with the entity
     */
    blockNumber: number;
    /**
     * Timestamp of the block
     */
    blockTimestamp: number;
    /**
     * Transaction ID associated with the entity
     */
    txID: string;
    /**
     * Transaction origin information
     */
    txOrigin: string;
    /**
     * Index of the clause
     */
    clauseIndex: number;
}

/**
 * TransferCriteria interface for filtering transfer logs.
 */
interface TransferCriteria {
    /**
     * Transaction origin filter for transfer criteria.
     */

    txOrigin?: string;
    /**
     * Sender's address filter.
     */

    sender?: string;
    /**
     * Recipient's address filter.
     */
    recipient?: string;
}

/**
 * Event interface representing event data.
 */
interface Event$1 {
    /**
     * The address related to the event.
     */
    address: string;

    /**
     * Event topics or categories.
     */
    topics: string[];

    /**
     * Event data.
     */
    data: string;
}

/**
 * Transfer interface representing transfer data.
 */
interface Transfer {
    /**
     * The sender's address in the transfer.
     */
    sender: string;

    /**
     * The recipient's address in the transfer.
     */
    recipient: string;

    /**
     * The amount being transferred.
     */
    amount: string;
}

/**
 * EventLogs interface, combining Event and EventMetadata.
 */
interface EventLogs extends Event$1 {
    /**
     * Event logs with associated metadata
     */
    meta: Metadata;
}

/**
 * TransferLogs interface, combining Transfer and WithMeta.
 */
interface TransferLogs extends Transfer {
    /**
     * Transfer logs with associated metadata
     */
    meta: Metadata;
}

/**
 * The `LogsClient` class provides methods to interact with log-related endpoints
 * of the VechainThor blockchain. It allows filtering event and transfer logs.
 */
declare class LogsModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the vechain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Filters event logs based on the provided criteria.
     *
     * @param filterOptions - An object specifying filtering criteria for event logs.
     * @returns A promise that resolves to filtered event logs.
     */
    filterEventLogs(filterOptions: FilterEventLogsOptions): Promise<EventLogs[]>;
    /**
     * Filters transfer logs based on the provided criteria.
     *
     * @param filterOptions - An object specifying filtering criteria for transfer logs.
     * @returns A promise that resolves to filtered transfer logs.
     */
    filterTransferLogs(filterOptions: FilterTransferLogsOptions): Promise<TransferLogs[]>;
}

/* --- Input options start --- */



/**
 * Input options for Blocks module.
 */
interface BlocksModuleOptions {
    /**
     * (Optional) Whether the polling is enabled.
     */
    isPollingEnabled?: boolean;
    /**
     * (Optional) Callback function called when an error occurs.
     */
    onBlockError?: (error: Error) => undefined;
}

/**
 * Options for `waitForBlockCompressed` and  `waitForBlockExpanded` methods.
 */
interface WaitForBlockOptions {
    /**
     * Timeout in milliseconds.
     * After this time, the method will throw an error.
     */
    timeoutMs?: number;
    /**
     * Interval in milliseconds.
     * The method will check the blocks status every `intervalMs` milliseconds.
     */
    intervalMs?: number;
}

/* --- Input options end --- */

/* --- Responses Outputs start --- */

/**
 * BlockDetail is an interface representing detailed information about a blockchain block.
 */
interface BlockDetail {
    /**
     * Unique identifier for the block.
     */
    id: string;

    /**
     * Block number in the blockchain.
     */
    number: number;

    /**
     * Size of the block in bytes.
     */
    size: number;

    /**
     * Identifier of the parent block.
     */
    parentID: string;

    /**
     * Timestamp when the block was created.
     */
    timestamp: number;

    /**
     * Maximum gas limit for transactions in the block.
     */
    gasLimit: number;

    /**
     * Address of the beneficiary (miner) of the block.
     */
    beneficiary: string;

    /**
     * Total gas used by transactions in the block.
     */
    gasUsed: number;

    /**
     * Represents the Accumulated Witness Number (AWN) of the block.
     * It is used when selecting the trunk block in the Vechainthor consensus algorithm.
     *
     * @link see [VechainThor Trunk](https://docs.vechain.org/introduction-to-vechain/about-the-vechain-blockchain/consensus-deep-dive#meta-transaction-features-3)
     */
    totalScore: number;

    /**
     * Root hash of the transactions in the block.
     */
    txsRoot: string;

    /**
     * Optional features associated with transactions.
     */
    txsFeatures?: number;

    /**
     * Root hash of the state tree after applying transactions.
     */
    stateRoot: string;

    /**
     * Root hash of the receipts of transactions.
     */
    receiptsRoot: string;

    /**
     * Address of the signer or validator for the block.
     */
    signer: string;

    /**
     * Indicates if the block contains a community fund (com).
     */
    com?: boolean;

    /**
     * Indicates if the block is finalized (optional).
     */
    isFinalized?: boolean;

    /**
     * Since there is no computational competition in PoA, the “longest chain” rule does not apply.
     * Instead, we consider the better branch as the one witnessed by more AMs (Authority Masternodes).
     *
     * @link see [VechainThor Trunk](https://docs.vechain.org/introduction-to-vechain/about-the-vechain-blockchain/consensus-deep-dive#meta-transaction-features-3)
     */
    isTrunk: boolean;
}

/**
 * Type for the compressed block detail.
 * Here we have the transactions as an array of strings.
 */
interface CompressedBlockDetail extends BlockDetail {
    transactions: string[];
}

/**
 * Type for the expanded block detail.
 * Here we have the transactions expanded with the details.
 */
interface ExpandedBlockDetail extends BlockDetail {
    transactions: TransactionsExpandedBlockDetail[];
}

/**
 * Clause represents the individual operation in a blockchain transaction.
 */
interface Clause {
    /**
     * Destination or contract address of the clause.
     */
    to: string | null;
    /**
     * Amount of VET transferred in the clause. Zero value if no VET is transferred and we are
     * performing a smart contract transaction.
     */
    value: string;
    /**
     * Data sent along with the clause. Zero value if no data is sent.
     */
    data: string;
}

/**
 * Output represent the result or consequence of a blockchain transaction.
 */
interface Output {
    /**
     * address of the contract involved in the clause output.
     */
    contractAddress: string | null;
    /**
     * Events emitted by executing the clause.
     */
    events: Event$1[];
    /**
     * Transfers of VET or VIP180 tokens that occur from the clause.
     */
    transfers: Transfer[];
}

/**
 * TransactionsExpandedBlockDetail is an interface representing detailed information about transactions in a blockchain block.
 */
interface TransactionsExpandedBlockDetail {
    /**
     * Unique identifier for the transaction.
     */
    id: string;

    /**
     * Chain tag of the blockchain.
     */
    chainTag: string;

    /**
     * Reference to the block.
     */
    blockRef: string;

    /**
     * Expiration timestamp of the transaction.
     */
    expiration: number;

    /**
     * Clauses represent the individual conditions or terms in a blockchain transaction.
     */
    clauses: Clause[];

    /**
     * Gas price coefficient for the transaction.
     */
    gasPriceCoef: number;

    /**
     * Gas limit for the transaction.
     */
    gas: number;

    /**
     * Origin (sender) of the transaction.
     */
    origin: string;

    /**
     * Delegator associated with the transaction.
     */
    delegator: string;

    /**
     * Nonce value for preventing replay attacks.
     */
    nonce: string;

    /**
     * Transaction dependency.
     */
    dependsOn: string;

    /**
     * Size of the transaction in bytes.
     */
    size: number;

    /**
     * Gas used by the transaction.
     */
    gasUsed: number;

    /**
     * Account paying for the gas.
     */
    gasPayer: string;

    /**
     * Amount paid for the transaction.
     */
    paid: string;

    /**
     * Reward associated with the transaction.
     */
    reward: string;

    /**
     * Indicates if the transaction is reverted.
     */
    reverted: boolean;

    /**
     * Outputs represent the results or consequences of a blockchain transaction.
     */
    outputs: Output[];
}

/** The `BlocksModule` class encapsulates functionality for interacting with blocks
 * on the VechainThor blockchain.
 */
declare class BlocksModule {
    readonly thor: ThorClient;
    /**
     * The head block (best block). This is updated by the event poll instance every time a new block is produced.
     * @private
     */
    private headBlock;
    /**
     * Error handler for block-related errors.
     */
    onBlockError?: (error: Error) => undefined;
    /**
     * The Poll instance for event polling
     * @private
     */
    private pollInstance?;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the vechain blockchain API.
     * @param options - (Optional) Other optional parameters for polling and error handling.
     */
    constructor(thor: ThorClient, options?: BlocksModuleOptions);
    /**
     * Destroys the instance by stopping the event poll.
     */
    destroy(): void;
    /**
     * Sets up the event polling for the best block.
     * @private
     * */
    private setupPolling;
    /**
     * Retrieves details of a compressed specific block identified by its revision (block number or ID).
     *
     * @param revision - The block number or ID to query details for.
     * @returns A promise that resolves to an object containing the details of the compressed block.
     */
    getBlockCompressed(revision: string | number): Promise<CompressedBlockDetail | null>;
    /**
     * Retrieves details of an expanded specific block identified by its revision (block number or ID).
     *
     * @param revision - The block number or ID to query details for.
     * @returns A promise that resolves to an object containing the details of the expanded block.
     */
    getBlockExpanded(revision: string | number): Promise<ExpandedBlockDetail | null>;
    /**
     * Retrieves details of the latest block.
     *
     * @returns A promise that resolves to an object containing the compressed block details.
     */
    getBestBlockCompressed(): Promise<CompressedBlockDetail | null>;
    /**
     * Retrieves details of the latest block.
     *
     * @returns A promise that resolves to an object containing the expanded block details.
     */
    getBestBlockExpanded(): Promise<ExpandedBlockDetail | null>;
    /**
     * Asynchronously retrieves a reference to the best block in the blockchain.
     *
     * This method first calls `getBestBlockCompressed()` to obtain the current best block. If no block is found (i.e., if `getBestBlockCompressed()` returns `null`),
     * the method returns `null` indicating that there's no block to reference. Otherwise, it extracts and returns the first 18 characters of the
     * block's ID, providing the ref to the best block.
     *
     * @returns {Promise<string | null>} A promise that resolves to either a string representing the first 18 characters of the best block's ID,
     * or `null` if no best block is found.
     *
     * @Example:
     * const blockRef = await getBestBlockRef();
     * if (blockRef) {
     *     console.log(`Reference to the best block: ${blockRef}`);
     * } else {
     *     console.log("No best block found.");
     * }
     */
    getBestBlockRef(): Promise<string | null>;
    /**
     * Retrieves the finalized block.
     *
     * @returns A promise that resolves to an object containing the finalized block.
     */
    getFinalBlockCompressed(): Promise<CompressedBlockDetail | null>;
    /**
     * Retrieves details of the finalized block.
     *
     * @returns A promise that resolves to an object containing the finalized block details.
     */
    getFinalBlockExpanded(): Promise<ExpandedBlockDetail | null>;
    /**
     * Synchronously waits for a specific block revision using polling.
     *
     * @param blockNumber - The block number to wait for.
     * @param options - (Optional) Allows to specify timeout and interval in milliseconds
     * @returns A promise that resolves to an object containing the compressed block.
     */
    private _waitForBlock;
    /**
     * Synchronously waits for a specific block revision using polling.
     *
     * @param blockNumber - The block number to wait for.
     * @param options - (Optional) Allows to specify timeout and interval in milliseconds
     * @returns A promise that resolves to an object containing the compressed block.
     */
    waitForBlockCompressed(blockNumber: number, options?: WaitForBlockOptions): Promise<CompressedBlockDetail | null>;
    /**
     * Synchronously waits for a specific expanded block revision using polling.
     *
     * @param blockNumber - The block number to wait for.
     * @param options - (Optional) Allows to specify timeout and interval in milliseconds
     * @returns A promise that resolves to an object containing the expanded block details.
     */
    waitForBlockExpanded(blockNumber: number, options?: WaitForBlockOptions): Promise<ExpandedBlockDetail | null>;
    /**
     * Returns the head block (best block).
     * @returns {BlockDetail | null} The head block (best block).
     */
    getHeadBlock(): CompressedBlockDetail | null;
    /**
     * Retrieves details of the genesis block.
     *
     * @returns A promise that resolves to an object containing the block details of the genesis block.
     */
    getGenesisBlock(): Promise<CompressedBlockDetail | null>;
}

/**
 * Transaction clause type for transaction simulation having value only string.
 */
type SimulateTransactionClause = TransactionClause;

/* --- Input options start --- */

/**
 * Options for `waitForTransaction` method.
 */
interface WaitForTransactionOptions {
    /**
     * Timeout in milliseconds.
     * After this time, the method will throw an error.
     */
    timeoutMs?: number;
    /**
     * Interval in milliseconds.
     * The method will check the transaction status every `intervalMs` milliseconds.
     */
    intervalMs?: number;
}

/**
 * Options for `buildTransactionBody` method.
 */
interface TransactionBodyOptions {
    /**
     * Coefficient used to calculate the gas price for the transaction.
     * Value must be between 0 and 255.
     */
    gasPriceCoef?: number;

    /**
     * The expiration time of the transaction.
     * The transaction will expire after the number of blocks specified by this value.
     */
    expiration?: number;

    /**
     * The ID of the transaction that this transaction depends on.
     */
    dependsOn?: string;

    /**
     * Whether the transaction is delegated to another account for gas payment.
     */
    isDelegated?: boolean;
}

/**
 * Options for `signTransaction` method.
 */
type SignTransactionOptions =
    | { delegatorUrl: string; delegatorPrivateKey?: never }
    | { delegatorPrivateKey: string; delegatorUrl?: never };

/**
 * Input options for:
 * * getTransactionReceipt
 * Methods
 */
interface GetTransactionReceiptInputOptions {
    /**
     * (Optional) The block number or ID to reference the transaction.
     */
    head?: string;
}

/**
 * Input options for:
 * * getTransaction
 * Methods
 */
type GetTransactionInputOptions = GetTransactionReceiptInputOptions & {
    /**
     * (Optional) If true, returns the raw transaction data instead of the parsed transaction object.
     */
    raw?: boolean;

    /**
     * (Optional) If true, returns the pending transaction details instead of the final transaction details.
     */
    pending?: boolean;
};

/**
 * Type for transaction simulation options.
 */
interface SimulateTransactionOptions {
    /**
     * The block number or block ID of which the transaction simulation is based on
     */
    revision?: string;
    /**
     * The offered gas for the transaction simulation
     */
    gas?: number;
    /**
     * The price of gas for the transaction simulation
     */
    gasPrice?: string;
    /**
     * The caller of the transaction simulation. (i.e., the address that performs the transaction)
     */
    caller?: string;

    // ------ EXTENDED EVM CONTEXT OPTIONS Start ------ //

    /*
        The following options are useful when simulating transactions that provide additional context to the EVM.
        The additional context is handled by the built-in Extension-V2 Smart contract (https://docs.vechain.org/developer-resources/built-in-contracts#extension-v2-sol)

        The contract allows for smart contract developers to obtain additional context about the transaction in their smart contract code, for example:
        - The expiration of the transaction
        - The block reference of the transaction
        - The gas payer of the transaction
        - The proved work of the transaction (https://docs.vechain.org/core-concepts/transactions/transaction-calculation#proof-of-work)
    */

    /**
     * The VechainThor blockchain allows for transaction-level proof of work (PoW) and converts the proved work into extra gas price that will be used by
     * the system to generate more reward to the block generator, the Authority Masternode, that validates the transaction.
     * In other words, users can utilize their local computational power to make their transactions more likely to be included in a new block.
     *
     * @link [VechainThor Proof of Work](https://docs.vechain.org/core-concepts/transactions/transaction-calculation#proof-of-work)
     */
    provedWork?: string;
    /**
     * The address that pays for the gas fee of the transaction simulation.
     * If different from the caller, then a delegated transaction is simulated.
     */
    gasPayer?: string;
    /**
     * The expiration of the transaction simulation.
     * Represents how long, in terms of the number of blocks, the transaction will be allowed to be mined in VechainThor
     */
    expiration?: number;
    /**
     * BlockRef stores the reference to a particular block whose next block is the earliest block the current transaction can be included.
     *
     * @link [VechainThor BlockRef](https://docs.vechain.org/core-concepts/transactions/meta-transaction-features/controllable-transaction-lifecycle)
     */
    blockRef?: string;

    // ------ EXTENDED EVM CONTEXT OPTIONS Start ------ //
}

/* --- Input options end --- */

/* --- Responses Outputs start --- */

/**
 * Represents the result of sending a transaction.
 *
 * @interface SendTransactionResult
 */
interface SendTransactionResult {
    /**
     * The unique identifier associated with the transaction.
     *
     * @type {string}
     */
    id: string;

    wait: () => Promise<TransactionReceipt | null>;
}

/**
 * Represents the result of getting a delegation signature.
 */
interface GetDelegationSignatureResult {
    /**
     * The signature of the transaction.
     */
    signature: string;
}

/**
 * Transaction Metadata interface.
 */
interface TransactionMetadata {
    blockID: string;
    blockNumber: number;
    blockTimestamp: number;
    txID?: string;
    txOrigin?: string;
}

/**
 * Type for RAW transaction detail.
 * It is the response of `getTransaction` with `raw` set to `true`.
 */
interface TransactionDetailRaw {
    /**
     * Raw data
     */
    raw: string;
    /**
     * Transaction meta data
     */
    meta: Omit<TransactionMetadata, 'txID' | 'txOrigin'>;
}

/**
 * Type for NO RAW transaction detail.
 * It is the response of `getTransaction` with `raw` set to `false`.
 */
type TransactionDetailNoRaw = TransactionBody & {
    id: string;
    origin: string;
    delegator: string | null;
    size: number;
    meta: TransactionMetadata;
};

/**
 * Type for transaction detail.
 */
type TransactionDetail = TransactionDetailRaw | TransactionDetailNoRaw;

/**
 * Type for transaction receipt.
 */
interface TransactionReceipt {
    /**
     * Gas used in the transaction
     */
    gasUsed: number;
    /**
     * For delegated transactions the gas payer
     * */
    gasPayer: string;
    /**
     * Energy paid for used gas
     */
    paid: string;
    /**
     * Energy reward given to block proposer
     */
    reward: string;
    /**
     * If the transaction has been reverted
     */
    reverted: boolean;
    /**
     * Outputs of the transaction, e.g. contract, events, transfers
     */
    outputs: Output[];
    /**
     * Data associated with the transaction e.g. blockID, blockNumber, txID
     */
    meta: TransactionMetadata;
}

/**
 * Type for transaction call simulation result.
 */
interface TransactionSimulationResult {
    /**
     * Data returned from the transaction simulation
     */
    data: string;
    /**
     * Events emitted from the transaction simulation
     */
    events: Event[];
    /**
     * Transfers that occur from the transaction simulation
     */
    transfers: Transfer[];
    /**
     * Gas used from the transaction simulation
     */
    gasUsed: number;
    /**
     * Boolean indicating if the transaction simulation reverted
     */
    reverted: boolean;
    /**
     * Error message from the transaction simulation if it reverted
     */
    vmError: string;
}

/**
 * The `TransactionsModule` handles transaction related operations and provides
 * convenient methods for sending transactions and waiting for transaction confirmation.
 */
declare class TransactionsModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the vechain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Retrieves the details of a transaction.
     *
     * @param id - Transaction ID of the transaction to retrieve.
     * @param options - (Optional) Other optional parameters for the request.
     * @returns A promise that resolves to the details of the transaction.
     */
    getTransaction(id: string, options?: GetTransactionInputOptions): Promise<TransactionDetail | null>;
    /**
     * Retrieves the receipt of a transaction.
     *
     * @param id - Transaction ID of the transaction to retrieve.
     * @param options - (Optional) Other optional parameters for the request.
     *                  If `head` is not specified, the receipt of the transaction at the best block is returned.
     * @returns A promise that resolves to the receipt of the transaction.
     */
    getTransactionReceipt(id: string, options?: GetTransactionReceiptInputOptions): Promise<TransactionReceipt | null>;
    /**
     * Retrieves the receipt of a transaction.
     *
     * @param raw - The raw transaction.
     * @returns The transaction id of send transaction.
     */
    sendRawTransaction(raw: string): Promise<SendTransactionResult>;
    /**
     * Sends a signed transaction to the network.
     *
     * @param signedTx - the transaction to send. It must be signed.
     *
     * @returns A promise that resolves to the transaction ID of the sent transaction.
     *
     * @throws an error if the transaction is not signed or if the transaction object is invalid.
     */
    sendTransaction(signedTx: Transaction): Promise<SendTransactionResult>;
    /**
     * Waits for a transaction to be included in a block.
     *
     * @param txID - The transaction ID of the transaction to wait for.
     * @param options - Optional parameters for the request. Includes the timeout and interval between requests.
     *                  Both parameters are in milliseconds. If the timeout is not specified, the request will not time out!
     *
     * @returns A promise that resolves to the transaction receipt of the transaction. If the transaction is not included in a block before the timeout,
     *          the promise will resolve to `null`.
     *
     * @throws an error if the transaction ID is invalid.
     */
    waitForTransaction(txID: string, options?: WaitForTransactionOptions): Promise<TransactionReceipt | null>;
    /**
     * Builds a transaction body with the given clauses without having to
     * specify the chainTag, expiration, gasPriceCoef, gas, dependsOn and reserved fields.
     *
     * @param clauses - The clauses of the transaction.
     * @param gas - The gas to be used to perform the transaction.
     * @param options - Optional parameters for the request. Includes the expiration, gasPriceCoef, dependsOn and isDelegated fields.
     *                  If the `expiration` is not specified, the transaction will expire after 32 blocks.
     *                  If the `gasPriceCoef` is not specified, the transaction will use the default gas price coef of 127.
     *                  If the `dependsOn is` not specified, the transaction will not depend on any other transaction.
     *                  If the `isDelegated` is not specified, the transaction will not be delegated.
     *
     * @returns A promise that resolves to the transaction body.
     *
     * @throws an error if the genesis block or the latest block cannot be retrieved.
     */
    buildTransactionBody(clauses: TransactionClause[], gas: number, options?: TransactionBodyOptions): Promise<TransactionBody>;
    /**
     * Simulates the execution of a transaction.
     * Allows to estimate the gas cost of a transaction without sending it, as well as to retrieve the return value(s) of the transaction.
     *
     * @param clauses - The clauses of the transaction to simulate.
     * @param options - (Optional) The options for simulating the transaction.
     *
     * @returns A promise that resolves to an array of simulation results.
     *          Each element of the array represents the result of simulating a clause.
     */
    simulateTransaction(clauses: SimulateTransactionClause[], options?: SimulateTransactionOptions): Promise<TransactionSimulationResult[]>;
    /**
     * Signs a transaction with the given private key and handles the delegation if the transaction is delegated.
     * If the transaction is delegated, the signature of the delegator is retrieved from the delegator endpoint or from the delegator private key.
     *
     * @see [Simple Gas Payer Standard](https://docs.vechain.org/core-concepts/transactions/meta-transaction-features/fee-delegation/designated-gas-payer-vip-191) - Designated Gas Payer (VIP-191)
     *
     * @param txBody - The transaction body to sign.
     * @param privateKey - The private key of the origin account.
     * @param delegatorOptions - Optional parameters for the request. Includes the `delegatorUrl` and `delegatorPrivateKey` fields.
     *                  Only one of the following options can be specified: `delegatorUrl`, `delegatorPrivateKey`.
     *
     * @returns A promise that resolves to the signed transaction.
     */
    signTransaction(txBody: TransactionBody, privateKey: string, delegatorOptions?: SignTransactionOptions): Promise<Transaction>;
    /**
     * Signs a transaction where the gas fee is paid by a delegator.
     *
     * @param unsignedTransactionBody - The unsigned transaction body to sign.
     * @param originPrivateKey - The private key of the origin account.
     * @param delegatorPrivateKey - (Optional) The private key of the delegator account.
     * @param delegatorUrl - (Optional) The URL of the endpoint of the delegator.
     *
     * @returns A promise that resolves to the signed transaction.
     *
     * @throws an error if the delegation fails.
     */
    private _signWithDelegator;
}

/**
 * Default timeout for HTTP requests, in milliseconds.
 */
declare const DEFAULT_HTTP_TIMEOUT = 30000;
/**
 * HTTP regex.
 */
declare const HTTP_REGEX: RegExp;
/**
 * HTTPS regex.
 */
declare const HTTPS_REGEX: RegExp;

/**
 * Node healthcheck Tolerance in seconds.
 * @example When set to 30, it means that we consider a node healthy even when it's off-sync by roughly 3 blocks.
 */
declare const NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS = 30;

/**
 * Converts an AxiosError into a standard Error.
 *
 * This function converts an AxiosError, which may contain HTTP response details, into a standard Error.
 * It handles cases where the AxiosError has an HTTP response with status and data.
 *
 * @param error - The AxiosError to convert into an Error.
 * @returns A standard Error with a descriptive message.
 */
declare const convertError: (error: AxiosError) => HTTPClientError;

/**
 * Constructs a query object for HTTP requests by filtering out undefined values.
 *
 * @param params - An object containing the query parameters with potential undefined values.
 * @returns An object containing only the defined query parameters.
 */
declare const buildQuery: (params: Record<string, string | boolean | undefined>) => Record<string, string>;

/**
 * Represents the parameters for making an HTTP request.
 *
 * This interface specifies options for configuring an HTTP request, including query parameters,
 * request body, custom headers, and a function to validate response headers.
 */
interface HttpParams {
    /**
     * Query parameters to include in the request.
     */
    query?: Record<string, string>;

    /**
     * The request body, which can be of any type.
     */
    body?: unknown;

    /**
     * Custom headers to be included in the request.
     */
    headers?: Record<string, string>;

    /**
     * A callback function to validate response headers.
     * @param headers - The response headers to validate.
     */
    validateResponseHeader?: (headers: Record<string, string>) => void;
}

/**
 * Represents the options for configuring an HTTP client.
 */
interface HttpClientOptions {
    /**
     * The timeout for an HTTP request, in milliseconds.
     */
    timeout?: number;

    /**
     * An Axios instance to use for sending HTTP requests.
     * This is useful for customizing the HTTP client, such as adding a custom user agent.
     */
    axiosInstance?: AxiosInstance;
}

/**
 * Represents a concrete implementation of the `IHttpClient` interface, providing methods for making HTTP requests.
 *
 * This class leverages Axios for handling HTTP requests and allows for interaction with HTTP services.
 * It is configured with a base URL and request timeout upon instantiation.
 */
declare class HttpClient {
    readonly baseURL: string;
    /**
     * Axios instance to make http requests
     */
    protected readonly axios: AxiosInstance;
    /**
     * Instantiates an `HttpClient` object with a specified base URL and HTTP request timeout.
     *
     * @param baseURL - The base URL for all network requests.
     * @param options - (Optional) An object containing additional configuration options for the HTTP client, such as a custom Axios instance and a request timeout.
     */
    constructor(baseURL: string, options?: HttpClientOptions);
    /**
     * Sends an HTTP request using the Axios library.
     *
     * @param method - The HTTP method to be used ('GET' or 'POST').
     * @param path - The path to access on the server relative to the base URL.
     * @param params - (Optional) Additional request parameters such as query parameters, request body, and custom headers.
     * @returns A promise that resolves to the response data from the HTTP request.
     * @throws {HTTPClientError} Will throw an error if the request fails, with more detailed information if the error is Axios-specific.
     */
    http(method: 'GET' | 'POST', path: string, params?: HttpParams): Promise<unknown>;
    /**
     * Validates the response headers if a validation function is provided.
     *
     * @param params - (Optional) The request parameters.
     * @param headers - The response headers.
     */
    private validateResponseHeader;
}

/**
 * Options for the force stop of the sync polling.
 */
interface SyncPollInputOptions {
    /**
     * The maximum number of iterations.
     * Poll will stop after this number of iterations, no matter condition is met or not.
     *
     * @note If not specified limit on iterations is NOT given.
     */
    maximumIterations?: number;

    /**
     * The interval of time (in milliseconds) between each function call.
     *
     * @note If not specified a default value is given.
     */
    requestIntervalInMilliseconds?: number;

    /**
     * The maximum amount of time (in milliseconds) to wait for the condition to be met.
     *
     * @note If not specified limit on time is NOT given.
     */
    maximumWaitingTimeInMilliseconds?: number;
}

/**
 * Poll until the condition is met.
 *
 * @note: Be careful!, this function is synchronous and will block the thread until the condition is met.
 * Thus mean it can run forever if the condition is never met.
 * To avoid infinite loop, you can use the `options.maximumIterations` parameter.
 *
 * @example It can be used to wait until:
 *  - A balance is updated after a transaction is sent
 *  - A transaction is mined
 *  - A block is mined
 *  ...
 *
 * @param pollingFunction - The function to be called.
 * @param options - Polling options. @see {SyncPollInputOptions} type. If not specified, the default values are used. In particular: `requestIntervalInMilliseconds` is 1000, `maximumIterations` is not specified
 *                  and `maximumWaitingTimeInMilliseconds` is not specified.
 * @returns An object with a `waitUntil` method. It blocks execution until the condition is met. When the condition is met, it returns the result of the poll.
 */
declare function SyncPoll<TReturnType>(pollingFunction: () => Promise<TReturnType> | TReturnType, options?: SyncPollInputOptions): {
    waitUntil: (condition: (data: TReturnType) => boolean) => Promise<TReturnType>;
};

/**
 * Poll in an event based way.
 * This Poll is Asynchronous. It exploits:
 * - The EventEmitter to emit events
 * - The setInterval function to poll
 *
 * @example It can be used to trigger events every time
 *  - When balance is updated after a transaction is sent a message is sent
 *  - When a transaction is mined a message is sent
 *  - When a certain block is mined an operation can start
 *  ...
 */
declare class EventPoll<TReturnType> extends EventEmitter {
    /**
     * The function to be called.
     */
    private readonly pollingFunction;
    /**
     * The interval of time (in milliseconds) between each request.
     */
    private readonly requestIntervalInMilliseconds;
    /**
     * The current iteration. It counts how many iterations have been done.
     * This parameter is useful to know how many iterations have been done.
     * For example, it can be used to stop the poll after a certain number of iterations.
     */
    private currentIteration;
    /**
     * The interval used to poll.
     */
    private intervalId?;
    /**
     * Error thrown during the execution of the poll.
     */
    private error?;
    /**
     * Create a new eventPoll.
     *
     * @param pollingFunction - The function to be called.
     * @param requestIntervalInMilliseconds - The interval of time (in milliseconds) between each request.
     */
    constructor(pollingFunction: () => Promise<TReturnType>, requestIntervalInMilliseconds: number);
    /**
     * Get how many iterations have been done.
     *
     * @returns The number of iterations.
     */
    get getCurrentIteration(): number;
    /**
     * Start listening to the event.
     */
    startListen(): void;
    /**
     * Stop listening to the event.
     */
    stopListen(): void;
    /**
     * Listen to the 'data' event.
     * This method is the redefinition of the EventEmitter.on method.
     * Because the EventEmitter.on method does not allow to specify the type of the data.
     * And we must be type safe.
     *
     * This is equivalent to:
     *
     * ```typescript
     * eventPoll.on('data', (data) => { ... });
     * ```
     * @param onDataCallback - The callback to be called when the event is emitted.
     */
    onData(onDataCallback: (data: TReturnType, eventPoll: EventPoll<TReturnType>) => void): this;
    /**
     * Listen to the 'start' event.
     * This happens when the poll is stopped.
     *
     * @param onStartCallback - The callback to be called when the event is emitted.
     */
    onStart(onStartCallback: (eventPoll: EventPoll<TReturnType>) => void): this;
    /**
     * Listen to the 'error' event.
     * This method is the redefinition of the EventEmitter.on method.
     * Because the EventEmitter.on method does not allow to specify the type of the data.
     * And we must be type safe.
     *
     * This is equivalent to:
     *
     * ```typescript
     * eventPoll.on('error', (data) => { ... });
     * ```
     * @param onErrorCallback - The callback to be called when the event is emitted.
     */
    onError(onErrorCallback: (error: Error) => void): this;
    /**
     * Listen to the 'stop' event.
     * This happens when the poll is stopped.
     *
     * @param onStopCallback - The callback to be called when the event is emitted.
     */
    onStop(onStopCallback: (eventPoll: EventPoll<TReturnType>) => void): this;
    /**
     * Basic interval loop function.
     * This function must be called into setInterval.
     * It calls the promise and emit the event.
     */
    private _intervalLoop;
}
/**
 * Create an event poll factory method.
 * This method is useful to create an event poll in a more readable way.
 *
 * @param callBack - The function to be called.
 * @param requestIntervalInMilliseconds - The interval of time (in milliseconds) between each request.
 */
declare function createEventPoll<TReturnType>(callBack: () => Promise<TReturnType>, requestIntervalInMilliseconds: number): EventPoll<TReturnType>;

declare const Poll: {
    SyncPoll: typeof SyncPoll;
    createEventPoll: typeof createEventPoll;
};

/**
 * Generates a query string from a record of key-value pairs.
 * Only includes keys in the query string whose values are defined.
 *
 * @param params - The record of key-value pairs.
 * @returns The query string.
 */
declare const toQueryString: (params: Record<string, string | number | boolean | undefined>) => string;
/**
 * Sanitizes a base URL by removing trailing slashes and adding the protocol if missing.
 *
 * @param url - The URL to validate.
 * @returns The sanitized URL without the protocol.
 */
declare const sanitizeWebsocketBaseURL: (url: string) => string;

/* --- Input options start --- */

interface EventOptions {
    /**
     * The block id to start from, defaults to the best block.
     */
    position?: string;
    /**
     * The contract address to filter events by.
     */
    contractAddress?: string;
    /**
     * The topic0 to filter events by.
     */
    topic0?: string;
    /**
     * The topic1 to filter events by.
     */
    topic1?: string;
    /**
     * The topic2 to filter events by.
     */
    topic2?: string;
    /**
     * The topic3 to filter events by.
     */
    topic3?: string;
    /**
     * The topic4 to filter events by.
     */
    topic4?: string;
}

interface VetTransferOptions {
    /**
     * The block id to start from, defaults to the best block.
     */
    position?: string;
    /**
     * The signer address to filter transfers by.
     */
    signerAddress?: string;
    /**
     * The sender address to filter transfers by.
     */
    sender?: string;
    /**
     * The receiver address to filter transfers by.
     */
    receiver?: string;
}

/**
 * Endpoints for the REST API.
 */
declare const thorest: {
    /**
     * Accounts related endpoints.
     */
    accounts: {
        get: {
            ACCOUNT_DETAIL: (address: string) => string;
            ACCOUNT_BYTECODE: (address: string) => string;
            STORAGE_AT: (address: string, position: string) => string;
        };
        post: {
            SIMULATE_TRANSACTION: (revision?: string) => string;
        };
    };
    /**
     * Blocks related endpoints.
     */
    blocks: {
        get: {
            BLOCK_DETAIL: (revision: string | number) => string;
        };
    };
    /**
     * Nodes related endpoints.
     */
    nodes: {
        get: {
            NODES: () => string;
        };
    };
    /**
     * Logs related endpoints.
     */
    logs: {
        post: {
            EVENT_LOGS: () => string;
            TRANSFER_LOGS: () => string;
        };
    };
    /**
     * Transactions related endpoints.
     */
    transactions: {
        get: {
            TRANSACTION: (id: string) => string;
            TRANSACTION_RECEIPT: (id: string) => string;
        };
        post: {
            TRANSACTION: () => string;
        };
    };
    /**
     * Subscriptions related endpoints.
     */
    subscriptions: {
        get: {
            /**
             * Subscribe to new blocks.
             *
             * @param baseURL - The URL of the node to request the subscription from.
             * @param position - (optional) The block id to start from, defaults to the best block.
             *
             * @returns The websocket subscription URL.
             */
            BLOCK: (baseURL: string, position?: string) => string;
            /**
             * Subscribe to new events.
             *
             * @param baseURL - The URL of the node to request the subscription from.
             * @param options - (optional) The options for the subscription.
             *
             * @returns The websocket subscription URL.
             */
            EVENT: (baseURL: string, options?: EventOptions) => string;
            /**
             * Subscribe to new VET transfers.
             *
             * @param baseURL - The URL of the node to request the subscription from.
             * @param options - (optional) The options for the subscription.
             *
             * @returns The websocket subscription URL.
             */
            VET_TRANSFER: (baseURL: string, options?: VetTransferOptions) => string;
            /**
             * Subscribe to new legacy beats.
             * A beat is a notification that a new block has been added to the blockchain with a bloom filter which can be used to check if the block contains any relevant account.
             * @note This subscription has been improved with dynamic size bloom filter with the new `BEAT` subscription.
             *
             * @param baseURL - The URL of the node to request the subscription from.
             * @param position - (optional) The block id to start from, defaults to the best block.
             *
             * @returns The websocket subscription URL.
             */
            BEAT_LEGACY: (baseURL: string, position?: string) => string;
            /**
             * Subscribe to new beats.
             * A beat is a notification that a new block has been added to the blockchain with a bloom filter which can be used to check if the block contains any relevant account.
             *
             * @param baseURL - The URL of the node to request the subscription from.
             * @param position - (optional) The block id to start from, defaults to the best block.
             *
             * @returns The websocket subscription URL.
             */
            BEAT: (baseURL: string, position?: string) => string;
            /**
             * Subscribe to new transactions.
             *
             * @returns The websocket subscription URL.
             */
            NEW_TRANSACTIONS: (baseURL: string) => string;
        };
    };
    /**
     * Debug related endpoints.
     */
    debug: {
        post: {
            TRACE_TRANSACTION_CLAUSE: () => string;
            TRACE_CONTRACT_CALL: () => string;
            RETRIEVE_STORAGE_RANGE: () => string;
        };
    };
};

/* --------- Event types start --------- */

/**
 * An Event Parameter ABI object.
 */
interface EventParameter {
    /**
     * Whether the parameter is an indexed parameter.
     */
    indexed: boolean;
    /**
     * The name of the parameter.
     */
    name: string;
    /**
     * The type of the parameter.
     */
    type: string;
    /**
     * The internal type of the parameter.
     */
    internalType?: string;
}

/**
 * An Event ABI object.
 */
interface EventAbi {
    /**
     * Whether the event was declared as anonymous.
     */
    anonymous: boolean;
    /**
     * The inputs of the event.
     */
    inputs: EventParameter[];
    /**
     * The name of the event.
     */
    name: string;
    /**
     * The type of the event. For an event, this is always 'event'.
     */
    type: string;
}

/**
 * An Ethers Event Fragment object.
 *
 * @see [Ethers Event Fragment](https://docs.ethers.org/v6/api/abi/abi-coder/#EventFragment)
 */
type EventFragment = vechain_sdk_core_ethers.EventFragment;

/**
 * An event represented as a string, an EventAbi object or an ethers EventFragment object.
 * If a string is provided, it must adhere to ether's Format Types.
 *
 * @see [Ethers Format Types](https://docs.ethers.org/v5/api/utils/abi/interface/#Interface--formatting)
 * @see [Ethers Event Fragment](https://docs.ethers.org/v6/api/abi/abi-coder/#EventFragment)
 */
type EventLike = string | EventAbi | EventFragment;

/* --------- Event types end --------- */

/* --- Input options start --- */

/**
 * Options for event subscription.
 */
interface EventSubscriptionOptions {
    /**
     * The block id from which to start the subscription.
     *
     * @note the Block ID must refer to a block that does not exceed the backtrace limit of the node. (Default: 1000)
     * @see [Backtrace limit](https://docs.vechain.org/start-building/tutorials/how-to-run-a-thor-solo-node#command-line-options)
     */
    blockID?: string;

    /**
     * The address of the contract that emitted the event to subscribe to.
     */
    address?: string;
}

interface BlockSubscriptionOptions {
    /**
     * The block id from which to start the subscription.
     *
     * @note the Block ID must refer to a block that does not exceed the backtrace limit of the node. (Default: 1000)
     * @see [Backtrace limit](https://docs.vechain.org/start-building/tutorials/how-to-run-a-thor-solo-node#command-line-options)
     */
    blockID?: string;
}

interface VETtransfersSubscriptionOptions {
    /**
     * The block id from which to start the subscription.
     *
     * @note the Block ID must refer to a block that does not exceed the backtrace limit of the node. (Default: 1000)
     * @see [Backtrace limit](https://docs.vechain.org/start-building/tutorials/how-to-run-a-thor-solo-node#command-line-options)
     */
    blockID?: string;

    /**
     * The address of the contract that emitted the event to subscribe to.
     */
    signerAddress?: string;

    /**
     * The address of the sender of the VET transfer to subscribe to.
     */
    sender?: string;

    /**
     * The address of the recipient of the VET transfer to subscribe to.
     */
    recipient?: string;
}

/**
 * Subscriptions utilities.
 * Contains functions for obtaining URLs for subscribing to events through a websocket connection.
 */
declare const subscriptions: {
    getEventSubscriptionUrl: (baseURL: string, event: EventLike, indexedValues?: unknown[] | undefined, options?: EventSubscriptionOptions | undefined) => string;
    getBlockSubscriptionUrl: (baseURL: string, options?: BlockSubscriptionOptions | undefined) => string;
    getNewTransactionsSubscriptionUrl: (baseURL: string) => string;
    getVETtransfersSubscriptionUrl: (baseURL: string, options?: VETtransfersSubscriptionOptions | undefined) => string;
    getLegacyBeatSubscriptionUrl: (baseURL: string, options?: BlockSubscriptionOptions | undefined) => string;
    getBeatSubscriptionUrl: (baseURL: string, options?: BlockSubscriptionOptions | undefined) => string;
};

/**
 * Provide a set of utils for the delegation type.
 * It is a mutual exclusion between delegatorPrivateKey and delegatorUrl. (@see SignTransactionOptions)
 *
 * The aim of this handler is to:
 *   - Understand the kind of delegation and the delegation info
 *   - Provide a method to get the delegation signature
 *
 * @param delegator - The delegator options.
 */
declare const DelegationHandler: (delegator?: SignTransactionOptions | null) => {
    isDelegated: () => boolean;
    delegatorOrUndefined: () => SignTransactionOptions | undefined;
    delegatorOrNull: () => SignTransactionOptions | null;
    getDelegationSignatureUsingUrl: (tx: Transaction, originAddress: string, httpClient: HttpClient) => Promise<Buffer>;
};

/* --------- Input types Start --------- */

type ContractTransactionOptions = Omit<TransactionBodyOptions, 'isDelegated'>;

/* --------- Input types End --------- */

/**
 * Defines the options for executing a contract call within a blockchain environment.
 */
type ContractCallOptions = SimulateTransactionOptions;

type ContractCallResult = vechain_sdk_core_ethers.Result;

/**
 * Represents a generic contract function type that accepts an arbitrary number of arguments
 * and returns a promise that resolves to a generic type `T`. This type is typically used to
 * model the behavior of smart contract functions in a blockchain context.
 *
 * @typeParam T - The expected return type of the promise. Defaults to `unknown` if not specified.
 * @param args - An array of arguments that the contract function accepts. The types of these arguments
 *               are not specified, allowing for flexibility in function signatures.
 * @returns A promise that resolves to the type `T`, representing the result of the contract function execution.
 */
type ContractFunction<T = unknown> = (...args: unknown[]) => Promise<T>;

/**
 * Defines a mapping of contract function names to their corresponding read-only contract functions.
 * Each function in this record is expected to return a `Promise` that resolves to `ContractCallResult`,
 * which should encapsulate the result of a read-only contract call.
 *
 * The keys of this record represent the names of the contract functions, and the values are the contract
 * functions themselves, adhering to the `ContractFunction` type with `ContractCallResult` as the return type.
 */
type ContractFunctionRead = Record<
    string,
    ContractFunction<ContractCallResult>
>;

/**
 * Defines a mapping of contract function names to their corresponding transactional contract functions.
 * Each function in this record is expected to return a `Promise` that resolves to `SendTransactionResult`,
 * which should encapsulate the result of a transactional contract call (e.g., modifying state on the blockchain).
 *
 * The keys of this record represent the names of the contract functions, and the values are the contract
 * functions themselves, adhering to the `ContractFunction` type with `SendTransactionResult` as the return type.
 */
type ContractFunctionTransact = Record<
    string,
    ContractFunction<SendTransactionResult>
>;

/**
 * A class representing a smart contract deployed on the blockchain.
 */
declare class Contract {
    readonly thor: ThorClient;
    readonly address: string;
    readonly abi: InterfaceAbi;
    private callerPrivateKey?;
    readonly deployTransactionReceipt: TransactionReceipt | undefined;
    read: ContractFunctionRead;
    transact: ContractFunctionTransact;
    private contractCallOptions;
    private contractTransactionOptions;
    /**
     * Initializes a new instance of the `Contract` class.
     * @param address The address of the contract.
     * @param abi The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.
     * @param thor An instance of ThorClient to interact with the blockchain.
     * @param callerPrivateKey The private key used for signing transactions.
     * @param transactionReceipt (Optional) The transaction receipt of the contract deployment.
     */
    constructor(address: string, abi: InterfaceAbi, thor: ThorClient, callerPrivateKey?: string, transactionReceipt?: TransactionReceipt);
    /**
     * Sets the options for contract calls.
     * @param options - The contract call options to set.
     * @returns The updated contract call options.
     */
    setContractReadOptions(options: ContractCallOptions): ContractCallOptions;
    /**
     * Clears the current contract call options, resetting them to an empty object.
     */
    clearContractReadOptions(): void;
    /**
     * Sets the options for contract transactions.
     * @param options - The contract transaction options to set.
     * @returns The updated contract transaction options.
     */
    setContractTransactOptions(options: ContractTransactionOptions): ContractTransactionOptions;
    /**
     * Clears the current contract transaction options, resetting them to an empty object.
     */
    clearContractTransactOptions(): void;
    /**
     * Sets the private key of the caller for signing transactions.
     * @param privateKey
     */
    setCallerPrivateKey(privateKey: string): string;
    /**
     * Get the private key of the caller for signing transactions.
     * @returns The private key of the caller.
     */
    getCallerPrivateKey(): string | undefined;
    /**
     * Creates a Proxy object for reading contract functions, allowing for the dynamic invocation of contract read operations.
     * @returns A Proxy that intercepts calls to read contract functions, automatically handling the invocation with the configured options.
     * @private
     */
    private getReadProxy;
    /**
     * Creates a Proxy object for transacting with contract functions, allowing for the dynamic invocation of contract transaction operations.
     * @returns A Proxy that intercepts calls to transaction contract functions, automatically handling the invocation with the configured options.
     * @private
     */
    private getTransactProxy;
    /**
     * Retrieves the function fragment for the specified function name.
     * @param prop - The name of the function.
     * @private
     * @throws An error if the specified function name or symbol is not found in the contract's ABI. The error includes
     * the `ERROR_CODES.ABI.INVALID_FUNCTION` code and a message indicating the function is not present in the ABI.
     *
     */
    private getFunctionFragment;
}

/**
 * A factory class for deploying smart contracts to a blockchain using a ThorClient.
 */
declare class ContractFactory {
    /**
     * The ABI (Application Binary Interface) of the contract.
     */
    private readonly abi;
    /**
     * The bytecode of the smart contract.
     */
    private readonly bytecode;
    /**
     * The private key used for signing transactions.
     */
    private readonly privateKey;
    /**
     * An instance of ThorClient to interact with the blockchain.
     */
    private readonly thor;
    /**
     * The result of the deployment transaction, undefined until a deployment is started.
     */
    private deployTransaction;
    /**
     * Initializes a new instance of the `ContractFactory` class.
     * @param abi The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.
     * @param bytecode The compiled bytecode of the contract, representing the contract's executable code.
     * @param privateKey The private key used for signing transactions during contract deployment, ensuring the deployer's identity.
     * @param thor An instance of ThorClient to interact with the blockchain.
     */
    constructor(abi: InterfaceAbi, bytecode: string, privateKey: string, thor: ThorClient);
    /**
     * Initiates the deployment of a smart contract.
     *
     * This method performs several steps to deploy a smart contract:
     * 1. Builds a transaction clause for deploying the contract.
     * 2. Estimates the gas cost required for the transaction.
     * 3. Constructs the transaction body with the estimated gas cost.
     * 4. Signs the transaction using the provided private key.
     * 5. Sends the signed transaction to the blockchain.
     *
     * @param {DeployParams?} deployParams (Optional) parameters for contract deployment.
     * @param {ContractTransactionOptions?} options (Optional) transaction options, such as gas limit.
     * @returns {Promise<ContractFactory>} A promise that resolves to the instance of `ContractFactory`,
     *          allowing for fluent chaining of further actions or queries.
     * @throws {Error} Throws an error if any step in the deployment process fails.
     */
    startDeployment(deployParams?: DeployParams, options?: ContractTransactionOptions): Promise<ContractFactory>;
    /**
     * Waits for the completion of a contract deployment transaction.
     *
     * This method checks for the presence of a deployed transaction result and then
     * waits for the transaction to be processed. Upon successful processing, it
     * constructs and returns a new `Contract` instance based on the transaction receipt.
     *
     * @throws An error if the deployed transaction result is not found or if the
     *         contract deployment fails.
     * @returns {Promise<Contract>} A promise that resolves to a `Contract` instance
     *          once the deployment transaction is completed.
     */
    waitForDeployment(): Promise<Contract>;
    /**
     * Returns the deploy transaction result, if available.
     */
    getDeployTransaction(): SendTransactionResult | undefined;
}

/**
 * Represents a module for interacting with smart contracts on the blockchain.
 */
declare class ContractsModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the vechain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Creates a new instance of `ContractFactory` configured with the specified ABI, bytecode, and private key.
     * This factory is used to deploy new smart contracts to the blockchain network managed by this instance.
     *
     * @param abi - The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.
     * @param bytecode - The compiled bytecode of the contract, representing the contract's executable code.
     * @param privateKey - The private key used for signing transactions during contract deployment, ensuring the deployer's identity.
     * @returns An instance of `ContractFactory` configured with the provided ABI, bytecode, and private key, ready for deploying contracts.
     */
    createContractFactory(abi: InterfaceAbi, bytecode: string, privateKey: string): ContractFactory;
    /**
     * Initializes and returns a new Contract instance with the provided parameters.
     *
     * @param address - The blockchain address of the contract to load.
     * @param abi - The Application Binary Interface (ABI) of the contract, which defines the contract's methods and structures.
     * @param callerPrivateKey - Optional. The private key of the caller, used for signing transactions when interacting with the contract.
     * @returns A new instance of the Contract, initialized with the provided address, ABI, and optionally, a caller private key.
     */
    load(address: string, abi: InterfaceAbi, callerPrivateKey?: string): Contract;
    /**
     * Executes a read-only call to a smart contract function, simulating the transaction to obtain the result.
     *
     * @param contractAddress - The address of the smart contract to interact with.
     * @param functionFragment - The function fragment, including the name and types of the function to be called, derived from the contract's ABI.
     * @param functionData - An array of arguments to be passed to the smart contract function, corresponding to the function's parameters.
     * @param contractCallOptions - (Optional) Additional options for the contract call, such as the sender's address, gas limit, and gas price, which can affect the simulation's context.
     * @returns A promise that resolves to the decoded output of the smart contract function call, the format of which depends on the function's return types.
     *
     * The function simulates a transaction using the provided parameters without submitting it to the blockchain, allowing read-only operations to be tested without incurring gas costs or modifying the blockchain state.
     */
    executeContractCall(contractAddress: string, functionFragment: FunctionFragment, functionData: unknown[], contractCallOptions?: ContractCallOptions): Promise<ContractCallResult>;
    /**
     * Executes a transaction to interact with a smart contract function.
     *
     * @param privateKey - The private key for signing the transaction.
     * @param contractAddress - The address of the smart contract.
     * @param functionFragment - The function fragment, including the name and types of the function to be called, derived from the contract's ABI.
     * @param functionData - The input data for the function.
     * @param options - (Optional) An object containing options for the transaction body. Includes all options of the `buildTransactionBody` method
     *                  besides `isDelegated`.
     *                  @see {@link TransactionsModule.buildTransactionBody}
     *
     * @returns A promise resolving to a SendTransactionResult object.
     */
    executeContractTransaction(privateKey: string, contractAddress: string, functionFragment: FunctionFragment, functionData: unknown[], options?: ContractTransactionOptions): Promise<SendTransactionResult>;
    /**
     * Gets the base gas price in wei.
     * The base gas price is the minimum gas price that can be used for a transaction.
     * It is used to obtain the VTHO (energy) cost of a transaction.
     *
     * @link [Total Gas Price](https://docs.vechain.org/core-concepts/transactions/transaction-calculation#total-gas-price)
     *
     * @returns The base gas price in wei.
     */
    getBaseGasPrice(): Promise<unknown>;
}

/* --- Input options start --- */

type EstimateGasOptions = Omit<SimulateTransactionOptions, 'caller'> & {
    /**
     * percentage of gas to add on top of the estimated gas.
     * Value must be between (0, 1]. (e.g. 0.1 = 10%)
     */
    gasPadding?: number;
};

/* --- Input options end --- */

/* --- Responses Outputs start --- */

/**
 * The result of estimating the gas cost of a transaction.
 */
interface EstimateGasResult {
    /**
     * The total gas cost estimation of the transaction.
     */
    totalGas: number;

    /**
     * Boolean indicating whether the transaction reverted or not.
     */
    reverted: boolean;

    /**
     * Decoded Solidity revert reasons for each clause.
     * If the n-th clause reverted, then the n-th element of this array will be the decoded revert reason for the n-th clause.
     *
     * @note revertReasons will be undefined if the transaction did not revert.
     */
    revertReasons: Array<string | bigint>;

    /**
     * The error message produced by the Virtual Machine.
     *
     * @note vmErrors will be undefined if the transaction did not revert.
     */
    vmErrors: string[];
}

/**
 * The `GasModule` handles gas related operations and provides
 * convenient methods for estimating the gas cost of a transaction.
 */
declare class GasModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the vechain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Simulates a transaction and returns an object containing information regarding the gas used and whether the transaction reverted.
     *
     * @param clauses - The clauses of the transaction to simulate.
     * @param caller - The address of the account sending the transaction.
     * @param options - Optional parameters for the request. Includes all options of the `simulateTransaction` method excluding the `caller` option.
     *                  @see {@link TransactionsClient#simulateTransaction}
     *                  Also, includes the `gasPadding` option which is a percentage of gas to add on top of the estimated gas. The value must be between (0, 1].
     *
     * @note The caller option is suggested as estimation without this parameter may not be accurate.
     *
     * @returns An object containing information regarding the gas used and whether the transaction reverted, together with the decoded revert reason and VM errors.
     *
     * @throws an error if the clauses are invalid or if an error occurs during the simulation.
     */
    estimateGas(clauses: SimulateTransactionClause[], caller?: string, options?: EstimateGasOptions): Promise<EstimateGasResult>;
}

/**
 * Config for the '4byte' name type
 */
type FourByteNameConfig = Record<string, unknown>;

/**
 * Return type for the '4byte' name type
 */
type FourByteNameReturnType = Record<string, number>;

/**
 * Config for the 'bigram' name type
 */
type BigramNameConfig = Record<string, unknown>;

/**
 * Return type for the 'bigram' name type
 */
type BigramNameReturnType = Record<string, number>;

/**
 * Config for the 'call' name type
 */
type CallNameConfig = Record<string, unknown>;

/**
 * Return type for the 'call' name type
 */
interface CallNameReturnType {
    /**
     * Transaction parameters
     */
    from: string;
    gas: string;
    gasUsed: string;
    to: string;
    input: string;
    output: string;

    /**
     * Transaction errors (if any)
     */
    error?: string;

    /**
     * Trace clause type (/debug/tracers endpoint)
     */
    calls?: Array<{
        from: string;
        gas: string;
        gasUsed: string;
        to: string;
        input: string;
        output: string;
        type: string;
    }>;

    /**
     * Trace contract type (/debug/tracers/call endpoint)
     */
    value?: string;
    type?: string;
}

/**
 * Config for the default ('' or null) name type
 */
type DefaultNameConfig = Record<string, unknown>;

/**
 * Return type for the default ('' or null) name type
 */
interface DefaultNameReturnType {
    gas: number;
    failed: boolean;
    returnValue: string;
    structLogs: Array<{
        pc: number;
        op: string;
        gas: number;
        gasCost: number;
        depth: number;
        stack: string[];
    }>;
}

/**
 * Config for the 'evmdis' name type
 */
type EVMDisNameConfig = Record<string, unknown>;

/**
 * Return type for the 'evmdis' name type
 */
type EVMDisNameReturnType = Array<{
    op: number;
    depth: number;
    result: string[];
    len: number;
}>;

/**
 * Config for the 'noop' name type
 */
type NoopNameConfig = Record<string, unknown>;

/**
 * Return type for the 'noop' name type
 */
type NoopNameReturnType = Record<string, unknown>;

/**
 * Config for the 'opcount' name type
 */
type OPCountNameConfig = Record<string, unknown>;

/**
 * Return type for the 'opcount' name type
 */
type OPCountNameReturnType = number;

/**
 * Config for the 'prestate' name type
 */
type PreStateNameConfig = Record<string, unknown>;

/**
 * Return type for the 'prestate' name type
 */
type PreStateNameReturnType = Record<
    string,
    {
        balance: string;
        energy: string;
        code?: string;
        storage?: Record<string, string>;
    }
>;

/**
 * Config for the 'trigram' name type
 */
type TrigramNameConfig = Record<string, unknown>;

/**
 * Return type for the 'trigram' name type
 */
type TrigramNameReturnType = Record<string, number>;

/**
 * Config for the 'unigram' name type
 */
type UnigramNameConfig = Record<string, unknown>;

/**
 * Return type for the 'unigram' name type
 */
type UnigramNameReturnType = Record<string, number>;

/**
 * Type for target of TraceTransactionClause.
 */
interface TransactionTraceTarget {
    /**
     * Block ID.
     */
    blockID: string;
    /**
     * Transaction ID or Transaction index.
     */
    transaction: number | string;
    /**
     * Clause index.
     */
    clauseIndex: number;
}

/**
 * TracerName is the name of the tracer to use.
 *
 * It determines Output and Input configuration.
 *
 * An empty name stands for the default struct logger tracer.
 */
type TracerName =
    | ''
    | '4byte'
    | 'call'
    | 'noop'
    | 'prestate'
    | 'unigram'
    | 'bigram'
    | 'trigram'
    | 'evmdis'
    | 'opcount'
    | null;

/**
 * The configuration of the tracer.
 *
 * Used for traceTransactionClause and traceContractCall functions.
 *
 * It is specific to the name of the tracer.
 *
 * @see{TracerName}
 */
type TracerConfig<TraceNameType extends TracerName | undefined> =
    TraceNameType extends ''
        ? DefaultNameConfig
        : TraceNameType extends '4byte'
          ? FourByteNameConfig
          : TraceNameType extends 'call'
            ? CallNameConfig
            : TraceNameType extends 'noop'
              ? NoopNameConfig
              : TraceNameType extends 'prestate'
                ? PreStateNameConfig
                : TraceNameType extends 'unigram'
                  ? UnigramNameConfig
                  : TraceNameType extends 'bigram'
                    ? BigramNameConfig
                    : TraceNameType extends 'trigram'
                      ? TrigramNameConfig
                      : TraceNameType extends 'evmdis'
                        ? EVMDisNameConfig
                        : TraceNameType extends 'opcount'
                          ? OPCountNameConfig
                          : TraceNameType extends null
                            ? DefaultNameConfig
                            : TraceNameType extends undefined
                              ? DefaultNameConfig
                              : never;

/**
 * The return type of the tracer.
 *
 * Used for traceTransactionClause and traceContractCall functions.
 *
 * It is specific to the name of the tracer.
 *
 * @see{TracerName}
 */
type TraceReturnType<TraceNameType extends TracerName | undefined> =
    TraceNameType extends ''
        ? DefaultNameReturnType
        : TraceNameType extends '4byte'
          ? FourByteNameReturnType
          : TraceNameType extends 'call'
            ? CallNameReturnType
            : TraceNameType extends 'noop'
              ? NoopNameReturnType
              : TraceNameType extends 'prestate'
                ? PreStateNameReturnType
                : TraceNameType extends 'unigram'
                  ? UnigramNameReturnType
                  : TraceNameType extends 'bigram'
                    ? BigramNameReturnType
                    : TraceNameType extends 'trigram'
                      ? TrigramNameReturnType
                      : TraceNameType extends 'evmdis'
                        ? EVMDisNameReturnType
                        : TraceNameType extends 'opcount'
                          ? OPCountNameReturnType
                          : TraceNameType extends null
                            ? DefaultNameReturnType
                            : TraceNameType extends undefined
                              ? DefaultNameReturnType
                              : never;

/**
 * Type for input for trace contract call - target contract.
 */
interface ContractCallTraceContractTargetInput {
    /**
     * The recipient of the call. Null indicates contract deployment.
     */
    to?: string | null;

    /**
     * The input data for the contract call.
     */
    data?: string;

    /**
     * The amount of token to be transferred.
     */
    value?: string;
}

/**
 * Type for input for trace contract call - transaction options.
 */
type ContractCallTraceTransactionOptionsInput = Omit<
    SimulateTransactionOptions,
    'revision'
>;

/**
 * Type for input options
 * for retrieve storage range function
 */
interface RetrieveStorageRangeInputOptions {
    /**
     * The address of the contract/ account to be traced.
     */
    address?: string;

    /**
     * The start key of the storage range.
     * Default is 0x0000000000000000000000000000000000000000000000000000000000000000.
     */
    keyStart?: string;

    /**
     * The maximum number of results to be returned. Default is 1000.
     */
    maxResult?: number;
}

/**
 * Return type for retrieve storage range function
 */
interface RetrieveStorageRangeReturnType {
    /**
     * The next key to be used for the next retrieve storage range call.
     */
    nextKey: string | null;

    /**
     * The data is non-nullable, but an empty object is returned if no data is found.
     */
    storage: Record<
        string,
        {
            /**
             * Storage key.
             */
            key: string;

            /**
             * Storage value.
             */
            value: string;
        }
    >;
}

/** The `DebugModule` class encapsulates functionality to handle Debug
 * on the VechainThor blockchain.
 */
declare class DebugModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the vechain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Trace transaction clause.
     *
     * This endpoint allows you to create a tracer for a specific clause.
     * Tracers are instrumental in monitoring and analyzing the execution flow within the EVM.
     * You can customize the tracer using various options to tailor it to your specific debugging needs.
     *
     * @param input - The input for the trace transaction clause. It has:
     * * target - The target of the tracer. It is a combination of blockID, transaction (transaction ID or index into block), and clauseIndex.
     * * config - The configuration of the tracer. It is specific to the name of the tracer.
     * @param name - The name of the tracer to use. It determines Output and Input configuration.
     *
     * @throws{InvalidDataTypeError} - If the input is invalid.
     */
    traceTransactionClause(input: {
        target: TransactionTraceTarget;
        config?: TracerConfig<typeof name>;
    }, name?: TracerName): Promise<TraceReturnType<typeof name>>;
    /**
     * Trace a contract call.
     *
     * This endpoint enables clients to create a tracer for a specific function call.
     * You can customize the tracer using various options to suit your debugging requirements.
     *
     * @param input - The input for the trace contract call. It has:
     * * contractInput - The contract call information.
     * * config - The configuration of the tracer. It is specific to the name of the tracer.
     * * transactionOptions - The transaction options.
     * @param name - The name of the tracer to use. It determines Output and Input configuration.
     *
     * @throws{InvalidDataTypeError} - If the input is invalid.
     */
    traceContractCall(input: {
        contractInput?: ContractCallTraceContractTargetInput;
        transactionOptions?: ContractCallTraceTransactionOptionsInput;
        config?: TracerConfig<typeof name>;
    }, name?: TracerName): Promise<TraceReturnType<typeof name>>;
    /**
     * Retrieve the storage range.
     *
     * This endpoint enables clients to retrieve the storage range for the
     * coordinates specified in the `input` parameter.
     *
     * @param input - the coordinates to retrieve the storage range. It has:
     * * target - {@link TransactionTraceTarget} specifies `blockID`,
     *           `transaction` address and `clauseIndex` number.
     * * options - {@link RetrieveStorageRangeInputOptions} specified the
     *           `address` if the contract or account to retrieve the
     *           storage range for. Nullable.
     */
    retrieveStorageRange(input: {
        target: TransactionTraceTarget;
        options?: RetrieveStorageRangeInputOptions;
    }): Promise<RetrieveStorageRangeReturnType>;
    /**
     * Validate target of traceTransactionClause and retrieveStorageRange.
     *
     * @param target - Target of traceTransactionClause and retrieveStorageRange to validate.
     * @param functionName - The name of the function.
     *
     * @private
     *
     * @throws{InvalidDataTypeError} - If the input is invalid.
     */
    private validateTarget;
}

/**
 * The `ThorClient` class serves as an interface to interact with the vechain Thor blockchain.
 * It provides various methods.
 * Essentially, it can be considered a layer on top of the `ThorestClient`.
 */
declare class ThorClient {
    readonly httpClient: HttpClient;
    /**
     * The `AccountsModule` instance
     */
    readonly accounts: AccountsModule;
    /**
     * The `NodesModule` instance
     */
    readonly nodes: NodesModule;
    /**
     * The `BlocksModule` instance
     */
    readonly blocks: BlocksModule;
    /**
     * The `LogsModule` instance used for interacting with log-related endpoints.
     */
    readonly logs: LogsModule;
    readonly transactions: TransactionsModule;
    /**
     * The 'ContractClient' instance
     */
    readonly contracts: ContractsModule;
    /**
     * The `GasModule` instance
     */
    readonly gas: GasModule;
    /**
     * The `DebugModule` instance
     */
    readonly debug: DebugModule;
    /**
     * Constructs a new `ThorClient` instance with a given HTTP client.
     *
     * @param httpClient - The HTTP client instance used for making network requests.
     * @param options - (Optional) Other optional parameters for polling and error handling.
     */
    constructor(httpClient: HttpClient, options?: BlocksModuleOptions);
    /**
     * Destroys the `ThorClient` instance by stopping the event polling
     * and any other cleanup.
     */
    destroy(): void;
}

/**
 * The `AccountModule` class provides methods to interact with account-related endpoints
 * of the VechainThor blockchain. It allows fetching details, bytecode, and storage data
 * for a specific blockchain account.
 */
declare class AccountsModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the vechain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Retrieves account details such as balance of VET, VTHO, and if the address is a smart contract.
     *
     * @param address - The account address to query details for.
     * @param options - (Optional) Other optional parameters for the request.
     * @returns A promise that resolves to an object containing the account details (balance, energy, hasCode).
     *
     * @throws {InvalidDataTypeError} - Will throw an error if the revision is not a valid block number or ID
     *         or if the address is not a valid address.
     */
    getAccount(address: string, options?: AccountInputOptions): Promise<AccountDetail>;
    /**
     * Fetches the bytecode of a contract at a given address.
     *
     * @param address - The contract address to get the bytecode for.
     * @param options - (Optional) Other optional parameters for the request.
     * @returns A promise that resolves to the contract bytecode as a string.
     *
     * @throws {InvalidDataTypeError} - Will throw an error if the revision is not a valid block number or ID
     *         or if the address is not a valid address.
     */
    getBytecode(address: string, options?: AccountInputOptions): Promise<string>;
    /**
     * Retrieves the value from a smart contract's storage at a given position.
     *
     * @param address - The contract address to query storage from.
     * @param position - The position in the storage to retrieve the value from. Must be a 32 bytes hex string (66 characters including `0x` prefix).
     * @param options - (Optional) Other optional parameters for the request.
     * @returns A promise that resolves to the storage value in hex string format.
     *
     * @throws {InvalidDataTypeError} - Will throw an error if the revision is not a valid block number or ID
     *         or if the position is not a 32 bytes hex string or if the address is not a valid address.
     */
    getStorageAt(address: string, position: string, options?: AccountInputOptions): Promise<string>;
}

type network_AccountDetail = AccountDetail;
type network_AccountInputOptions = AccountInputOptions;
type network_AccountsModule = AccountsModule;
declare const network_AccountsModule: typeof AccountsModule;
type network_BlockDetail = BlockDetail;
type network_BlockSubscriptionOptions = BlockSubscriptionOptions;
type network_BlocksModule = BlocksModule;
declare const network_BlocksModule: typeof BlocksModule;
type network_BlocksModuleOptions = BlocksModuleOptions;
type network_Clause = Clause;
type network_CompressedBlockDetail = CompressedBlockDetail;
type network_ConnectedPeer = ConnectedPeer;
type network_Contract = Contract;
declare const network_Contract: typeof Contract;
type network_ContractCallOptions = ContractCallOptions;
type network_ContractCallResult = ContractCallResult;
type network_ContractFactory = ContractFactory;
declare const network_ContractFactory: typeof ContractFactory;
type network_ContractFunction<T = unknown> = ContractFunction<T>;
type network_ContractTransactionOptions = ContractTransactionOptions;
type network_ContractsModule = ContractsModule;
declare const network_ContractsModule: typeof ContractsModule;
declare const network_DEFAULT_HTTP_TIMEOUT: typeof DEFAULT_HTTP_TIMEOUT;
declare const network_DelegationHandler: typeof DelegationHandler;
type network_EventCriteria = EventCriteria;
type network_EventFragment = EventFragment;
type network_EventLike = EventLike;
type network_EventLogs = EventLogs;
type network_EventOptions = EventOptions;
type network_EventPoll<TReturnType> = EventPoll<TReturnType>;
declare const network_EventPoll: typeof EventPoll;
type network_EventSubscriptionOptions = EventSubscriptionOptions;
type network_ExpandedBlockDetail = ExpandedBlockDetail;
type network_FilterEventLogsOptions = FilterEventLogsOptions;
type network_FilterTransferLogsOptions = FilterTransferLogsOptions;
type network_GetDelegationSignatureResult = GetDelegationSignatureResult;
type network_GetTransactionInputOptions = GetTransactionInputOptions;
type network_GetTransactionReceiptInputOptions = GetTransactionReceiptInputOptions;
declare const network_HTTPS_REGEX: typeof HTTPS_REGEX;
declare const network_HTTP_REGEX: typeof HTTP_REGEX;
type network_HttpClient = HttpClient;
declare const network_HttpClient: typeof HttpClient;
type network_HttpClientOptions = HttpClientOptions;
type network_HttpParams = HttpParams;
type network_LogsModule = LogsModule;
declare const network_LogsModule: typeof LogsModule;
declare const network_NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS: typeof NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS;
type network_NodesModule = NodesModule;
declare const network_NodesModule: typeof NodesModule;
type network_Output = Output;
declare const network_Poll: typeof Poll;
type network_Range = Range;
type network_ResponseBytecode = ResponseBytecode;
type network_ResponseStorage = ResponseStorage;
type network_SendTransactionResult = SendTransactionResult;
type network_SignTransactionOptions = SignTransactionOptions;
type network_SimulateTransactionClause = SimulateTransactionClause;
type network_SimulateTransactionOptions = SimulateTransactionOptions;
type network_SyncPollInputOptions = SyncPollInputOptions;
type network_ThorClient = ThorClient;
declare const network_ThorClient: typeof ThorClient;
type network_TransactionBodyOptions = TransactionBodyOptions;
type network_TransactionDetail = TransactionDetail;
type network_TransactionDetailNoRaw = TransactionDetailNoRaw;
type network_TransactionReceipt = TransactionReceipt;
type network_TransactionSimulationResult = TransactionSimulationResult;
type network_TransactionsExpandedBlockDetail = TransactionsExpandedBlockDetail;
type network_TransactionsModule = TransactionsModule;
declare const network_TransactionsModule: typeof TransactionsModule;
type network_Transfer = Transfer;
type network_TransferLogs = TransferLogs;
type network_VETtransfersSubscriptionOptions = VETtransfersSubscriptionOptions;
type network_VetTransferOptions = VetTransferOptions;
type network_WaitForBlockOptions = WaitForBlockOptions;
type network_WaitForTransactionOptions = WaitForTransactionOptions;
declare const network_buildQuery: typeof buildQuery;
declare const network_convertError: typeof convertError;
declare const network_sanitizeWebsocketBaseURL: typeof sanitizeWebsocketBaseURL;
declare const network_subscriptions: typeof subscriptions;
declare const network_thorest: typeof thorest;
declare const network_toQueryString: typeof toQueryString;
declare namespace network {
  export { type network_AccountDetail as AccountDetail, type network_AccountInputOptions as AccountInputOptions, network_AccountsModule as AccountsModule, type network_BlockDetail as BlockDetail, type network_BlockSubscriptionOptions as BlockSubscriptionOptions, network_BlocksModule as BlocksModule, type network_BlocksModuleOptions as BlocksModuleOptions, type network_Clause as Clause, type network_CompressedBlockDetail as CompressedBlockDetail, type network_ConnectedPeer as ConnectedPeer, network_Contract as Contract, type network_ContractCallOptions as ContractCallOptions, type network_ContractCallResult as ContractCallResult, network_ContractFactory as ContractFactory, type network_ContractFunction as ContractFunction, type network_ContractTransactionOptions as ContractTransactionOptions, network_ContractsModule as ContractsModule, network_DEFAULT_HTTP_TIMEOUT as DEFAULT_HTTP_TIMEOUT, network_DelegationHandler as DelegationHandler, type Event$1 as Event, type network_EventCriteria as EventCriteria, type network_EventFragment as EventFragment, type network_EventLike as EventLike, type network_EventLogs as EventLogs, type network_EventOptions as EventOptions, network_EventPoll as EventPoll, type network_EventSubscriptionOptions as EventSubscriptionOptions, type network_ExpandedBlockDetail as ExpandedBlockDetail, type network_FilterEventLogsOptions as FilterEventLogsOptions, type network_FilterTransferLogsOptions as FilterTransferLogsOptions, type network_GetDelegationSignatureResult as GetDelegationSignatureResult, type network_GetTransactionInputOptions as GetTransactionInputOptions, type network_GetTransactionReceiptInputOptions as GetTransactionReceiptInputOptions, network_HTTPS_REGEX as HTTPS_REGEX, network_HTTP_REGEX as HTTP_REGEX, network_HttpClient as HttpClient, type network_HttpClientOptions as HttpClientOptions, type network_HttpParams as HttpParams, network_LogsModule as LogsModule, network_NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS as NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS, network_NodesModule as NodesModule, type network_Output as Output, network_Poll as Poll, type network_Range as Range, type network_ResponseBytecode as ResponseBytecode, type network_ResponseStorage as ResponseStorage, type network_SendTransactionResult as SendTransactionResult, type network_SignTransactionOptions as SignTransactionOptions, type network_SimulateTransactionClause as SimulateTransactionClause, type network_SimulateTransactionOptions as SimulateTransactionOptions, type network_SyncPollInputOptions as SyncPollInputOptions, network_ThorClient as ThorClient, type network_TransactionBodyOptions as TransactionBodyOptions, type network_TransactionDetail as TransactionDetail, type network_TransactionDetailNoRaw as TransactionDetailNoRaw, type network_TransactionReceipt as TransactionReceipt, type network_TransactionSimulationResult as TransactionSimulationResult, type network_TransactionsExpandedBlockDetail as TransactionsExpandedBlockDetail, network_TransactionsModule as TransactionsModule, type network_Transfer as Transfer, type network_TransferLogs as TransferLogs, type network_VETtransfersSubscriptionOptions as VETtransfersSubscriptionOptions, type network_VetTransferOptions as VetTransferOptions, type network_WaitForBlockOptions as WaitForBlockOptions, type network_WaitForTransactionOptions as WaitForTransactionOptions, network_buildQuery as buildQuery, network_convertError as convertError, network_sanitizeWebsocketBaseURL as sanitizeWebsocketBaseURL, network_subscriptions as subscriptions, network_thorest as thorest, network_toQueryString as toQueryString };
}

export { type AccountDetail, type AccountInputOptions, AccountsModule, type BlockDetail, type BlockSubscriptionOptions, BlocksModule, type BlocksModuleOptions, type Clause, type CompressedBlockDetail, type ConnectedPeer, Contract, type ContractCallOptions, type ContractCallResult, ContractFactory, type ContractFunction, type ContractTransactionOptions, ContractsModule, DEFAULT_HTTP_TIMEOUT, DelegationHandler, type Event$1 as Event, type EventCriteria, type EventFragment, type EventLike, type EventLogs, type EventOptions, EventPoll, type EventSubscriptionOptions, type ExpandedBlockDetail, type FilterEventLogsOptions, type FilterTransferLogsOptions, type GetDelegationSignatureResult, type GetTransactionInputOptions, type GetTransactionReceiptInputOptions, HTTPS_REGEX, HTTP_REGEX, HttpClient, type HttpClientOptions, type HttpParams, LogsModule, NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS, NodesModule, type Output, Poll, type Range, type ResponseBytecode, type ResponseStorage, type SendTransactionResult, type SignTransactionOptions, type SimulateTransactionClause, type SimulateTransactionOptions, type SyncPollInputOptions, ThorClient, type TransactionBodyOptions, type TransactionDetail, type TransactionDetailNoRaw, type TransactionReceipt, type TransactionSimulationResult, type TransactionsExpandedBlockDetail, TransactionsModule, type Transfer, type TransferLogs, type VETtransfersSubscriptionOptions, type VetTransferOptions, type WaitForBlockOptions, type WaitForTransactionOptions, buildQuery, convertError, network, sanitizeWebsocketBaseURL, subscriptions, thorest, toQueryString };

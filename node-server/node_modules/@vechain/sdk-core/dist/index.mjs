var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "../../node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && /* @__PURE__ */ function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// src/core.ts
var core_exports = {};
__export(core_exports, {
  BLOCK_REF_LENGTH: () => BLOCK_REF_LENGTH,
  BLOOM_REGEX_LOWERCASE: () => BLOOM_REGEX_LOWERCASE,
  BLOOM_REGEX_UPPERCASE: () => BLOOM_REGEX_UPPERCASE,
  DECIMAL_INTEGER_REGEX: () => DECIMAL_INTEGER_REGEX,
  ERC721_ABI: () => ERC721_ABI,
  HDNode: () => HDNode,
  HEX_ADDRESS_REGEX: () => HEX_ADDRESS_REGEX,
  HEX_REGEX: () => HEX_REGEX,
  HEX_REGEX_OPTIONAL_PREFIX: () => HEX_REGEX_OPTIONAL_PREFIX,
  Hex: () => Hex,
  MAINNET_NETWORK: () => MAINNET_NETWORK,
  MNEMONIC_WORDLIST_ALLOWED_SIZES: () => MNEMONIC_WORDLIST_ALLOWED_SIZES,
  NUMERIC_REGEX: () => NUMERIC_REGEX,
  PARAMS_ABI: () => PARAMS_ABI,
  PARAMS_ADDRESS: () => PARAMS_ADDRESS,
  PRIVATE_KEY_MAX_VALUE: () => PRIVATE_KEY_MAX_VALUE,
  RLP: () => RLP2,
  RLPBase: () => RLPBase,
  RLPProfiles: () => RLPProfiles,
  SCRYPT_PARAMS: () => SCRYPT_PARAMS,
  SIGNATURE_LENGTH: () => SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP: () => SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK: () => SOLO_NETWORK,
  TESTNET_NETWORK: () => TESTNET_NETWORK,
  THOR_ID_LENGTH: () => THOR_ID_LENGTH,
  TRANSACTIONS_GAS_CONSTANTS: () => TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND: () => TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND: () => TRANSACTION_SIGNATURE_KIND,
  Transaction: () => Transaction,
  TransactionHandler: () => TransactionHandler,
  TransactionUtils: () => TransactionUtils,
  UNSIGNED_TRANSACTION_RLP: () => UNSIGNED_TRANSACTION_RLP,
  VET_DERIVATION_PATH: () => VET_DERIVATION_PATH,
  VIP180_ABI: () => VIP180_ABI,
  VTHO_ADDRESS: () => VTHO_ADDRESS,
  X_PRIV_PREFIX: () => X_PRIV_PREFIX,
  X_PUB_PREFIX: () => X_PUB_PREFIX,
  ZERO_ADDRESS: () => ZERO_ADDRESS,
  ZERO_BUFFER: () => ZERO_BUFFER,
  abi: () => abi,
  addressUtils: () => addressUtils,
  assertCantGetFieldOnUnsignedTransaction: () => assertCantGetFieldOnUnsignedTransaction,
  assertCompactFixedHexBlobBuffer: () => assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer: () => assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData: () => assertFixedHexBlobKindData,
  assertIsAddress: () => assertIsAddress,
  assertIsArray: () => assertIsArray,
  assertIsRevisionForAccount: () => assertIsRevisionForAccount,
  assertIsRevisionForBlock: () => assertIsRevisionForBlock,
  assertIsSignedTransaction: () => assertIsSignedTransaction,
  assertIsValidBuffer: () => assertIsValidBuffer,
  assertIsValidHdNodeChainCode: () => assertIsValidHdNodeChainCode,
  assertIsValidHdNodeDerivationPath: () => assertIsValidHdNodeDerivationPath,
  assertIsValidPrivateKey: () => assertIsValidPrivateKey,
  assertIsValidReturnType: () => assertIsValidReturnType,
  assertIsValidSecp256k1MessageHash: () => assertIsValidSecp256k1MessageHash,
  assertIsValidTransactionSigningPrivateKey: () => assertIsValidTransactionSigningPrivateKey,
  assertValidHexBlobKindBuffer: () => assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData: () => assertValidHexBlobKindData,
  assertValidNumericKindBuffer: () => assertValidNumericKindBuffer,
  assertValidTransactionHead: () => assertValidTransactionHead,
  assertValidTransactionID: () => assertValidTransactionID,
  blake2b256: () => blake2b256,
  bloom: () => bloom,
  bloomUtils: () => bloomUtils,
  certificate: () => certificate,
  clauseBuilder: () => clauseBuilder,
  coder: () => coder,
  dataUtils: () => dataUtils,
  decodeBufferToHexWithLeadingZeros: () => decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex: () => decodeBufferToNumberOrHex,
  encodeBigIntToBuffer: () => encodeBigIntToBuffer,
  encodeCompactFixedHexBlob: () => encodeCompactFixedHexBlob,
  fragment: () => fragment,
  isDerivationPathValid: () => isDerivationPathValid,
  keccak256: () => keccak256,
  keystore: () => keystore,
  mnemonic: () => mnemonic,
  networkInfo: () => networkInfo,
  ofBuffer: () => ofBuffer,
  revisionUtils: () => revisionUtils,
  secp256k1: () => secp256k1,
  sha256: () => sha256,
  unitsUtils: () => unitsUtils,
  validateNumericKindData: () => validateNumericKindData,
  vechain_sdk_core_ethers: () => ethers11
});
import { ethers as ethers11 } from "ethers";

// src/abi/fragment.ts
import { ethers } from "ethers";
import { ABI, assert, buildError } from "@vechain/sdk-errors";

// src/abi/helpers/fragment.ts
var sanitizeValuesToEncode = (valuesToEncode, event) => {
  if (valuesToEncode.length === 0)
    return [];
  if (valuesToEncode.length > event.inputs.length)
    return valuesToEncode;
  const sanitizedValuesToEncode = [];
  const eventInputs = event.inputs;
  for (const input of eventInputs) {
    input.indexed === true ? sanitizedValuesToEncode.push(valuesToEncode.shift()) : sanitizedValuesToEncode.push(null);
  }
  return sanitizedValuesToEncode;
};

// src/abi/fragment.ts
var allowedSignatureFormats = ["sighash", "minimal", "full", "json"];
function getSignature(fragment2, formatType) {
  assert(
    "getSignature",
    allowedSignatureFormats.includes(formatType),
    ABI.INVALID_FORMAT_TYPE,
    `Signature format error: '${formatType}' is invalid. Allowed formats: ${allowedSignatureFormats.join(
      ", "
    )}`,
    { formatType }
  );
  return fragment2.format(formatType);
}
var Function = class {
  /**
   * The main fragment handled by ethers.js.
   *
   */
  fragment;
  /**
   * The main interface handled by ethers.js.
   */
  iface;
  /**
   * Creates a new Function instance from an ABI fragment.
   *
   * @throws{InvalidAbiFunctionError}
   * @param source - ABI fragment to use.
   */
  constructor(source) {
    try {
      this.fragment = ethers.FunctionFragment.from(source);
      this.iface = new ethers.Interface([this.fragment]);
    } catch (e) {
      throw buildError(
        "Function constructor",
        ABI.INVALID_FUNCTION,
        "Initialization failed: Cannot create Function fragment. Function format is invalid.",
        { source },
        e
      );
    }
  }
  /**
   * Get the signature hash of the function.
   *
   * @returns The signature hash of the function.
   */
  signatureHash() {
    return this.fragment.selector;
  }
  /**
   * Get the signature of the function.
   *
   * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
   * @returns The signature of the function.
   */
  signature(formatType) {
    return getSignature(this.fragment, formatType);
  }
  /**
   * Decode data using the function's ABI.
   *
   * @throws{InvalidAbiDataToDecodeError} - If the data cannot be decoded.
   * @param data - Data to decode.
   * @returns Decoding results.
   */
  decodeInput(data) {
    try {
      return this.iface.decodeFunctionData(this.fragment, data);
    } catch (e) {
      throw buildError(
        "decodeInput",
        ABI.INVALID_DATA_TO_DECODE,
        "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
        { data },
        e
      );
    }
  }
  /**
   * Decodes the output data from a transaction based on ABI (Application Binary Interface) specifications.
   * This method attempts to decode the given byte-like data into a readable format using the contract's interface.
   *
   * @param data - The `BytesLike` data to be decoded, typically representing the output of a contract function call.
   * @returns A `Result` object containing the decoded data.
   *
   * @throws{InvalidAbiDataToDecodeError} - If the data cannot be decoded.
   *
   * @example
   * ```typescript
   *   const decoded = contractInstance.decodeOutput(rawTransactionOutput);
   *   console.log('Decoded Output:', decoded);
   * ```
   */
  decodeOutput(data) {
    try {
      return this.iface.decodeFunctionResult(this.fragment, data);
    } catch (e) {
      throw buildError(
        "decodeOutput",
        ABI.INVALID_DATA_TO_DECODE,
        "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
        { data },
        e
      );
    }
  }
  /**
   * Encode data using the function's ABI.
   *
   * @throws{InvalidAbiDataToEncodeError}
   * @param dataToEncode - Data to encode.
   * @returns Encoded data.
   */
  encodeInput(dataToEncode) {
    try {
      return this.iface.encodeFunctionData(this.fragment, dataToEncode);
    } catch (e) {
      throw buildError(
        "encodeInput",
        ABI.INVALID_DATA_TO_ENCODE,
        "Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.",
        { dataToEncode },
        e
      );
    }
  }
};
var Event = class {
  /**
   * The main fragment handled by ethers.js.
   */
  fragment;
  /**
   * The main interface handled by ethers.js.
   */
  iface;
  /**
   * Creates a new Event instance from an ABI fragment.
   *
   * @throws{InvalidAbiEventError}
   * @param source - ABI fragment to use.
   */
  constructor(source) {
    try {
      this.fragment = ethers.EventFragment.from(source);
      this.iface = new ethers.Interface([this.fragment]);
    } catch (e) {
      throw buildError(
        "Event constructor",
        ABI.INVALID_EVENT,
        "Initialization failed: Event fragment creation is not possible due to invalid ABI data format.",
        { source },
        e
      );
    }
  }
  /**
   * Get the signature hash of the event.
   *
   * @returns The signature hash of the event.
   */
  signatureHash() {
    return this.fragment.topicHash;
  }
  /**
   * Get the signature of the event.
   *
   * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
   * @returns The signature of the event.
   */
  signature(formatType) {
    return getSignature(this.fragment, formatType);
  }
  /**
   * Decode event log data using the event's ABI.
   *
   * @throws{InvalidAbiDataToDecodeError}
   * @param data - Data to decode.
   * @returns Decoding results.
   */
  decodeEventLog(data) {
    try {
      return this.iface.decodeEventLog(
        this.fragment,
        data.data,
        data.topics
      );
    } catch (e) {
      throw buildError(
        "decodeEventLog",
        ABI.INVALID_DATA_TO_DECODE,
        "Decoding failed: Data and topics must be correctly formatted for ABI-compliant decoding.",
        { data },
        e
      );
    }
  }
  /**
   * Encode event log data using the event's ABI.
   *
   * @throws{InvalidAbiDataToEncodeError}
   * @param dataToEncode - Data to encode.
   * @returns Encoded data along with topics.
   */
  encodeEventLog(dataToEncode) {
    try {
      return this.iface.encodeEventLog(this.fragment, dataToEncode);
    } catch (e) {
      throw buildError(
        "encodeEventLog",
        ABI.INVALID_DATA_TO_ENCODE,
        "Encoding failed: Event data must be correctly formatted for ABI-compliant encoding.",
        { dataToEncode },
        e
      );
    }
  }
  /**
   * Encode event log topics using the event's ABI.
   *
   * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.
   *                         Only the values of the indexed parameters are needed.
   *
   * @returns Encoded topics array.
   */
  encodeFilterTopics(valuesToEncode) {
    try {
      const sanitizedValuesToEncode = sanitizeValuesToEncode(
        valuesToEncode,
        this.fragment
      );
      return this.iface.encodeFilterTopics(this.fragment, sanitizedValuesToEncode).map((topic) => topic ?? void 0);
    } catch (e) {
      throw buildError(
        "encodeFilterTopics",
        ABI.INVALID_DATA_TO_ENCODE,
        "Encoding topics failed: Event topics values must be correctly formatted for ABI-compliant encoding.",
        { valuesToEncode },
        e
      );
    }
  }
};
var fragment = {
  Function,
  Event
};

// src/abi/coder.ts
import { ethers as ethers2 } from "ethers";
import { ABI as ABI2, buildError as buildError2 } from "@vechain/sdk-errors";
var ethersCoder = new ethers2.AbiCoder();
function encode(type, value) {
  try {
    return ethersCoder.encode([type], [value]);
  } catch {
    throw buildError2(
      "encode",
      ABI2.INVALID_DATA_TO_ENCODE,
      "Encoding failed: Data must be a valid ABI type with corresponding valid data."
    );
  }
}
function encodeParams(types, values) {
  try {
    return ethersCoder.encode(types, values);
  } catch {
    throw buildError2(
      "encodeParams",
      ABI2.INVALID_DATA_TO_ENCODE,
      "Encoding failed: Data must be a valid ABI type with corresponding valid data."
    );
  }
}
function decode(types, data) {
  try {
    const decoded = ethersCoder.decode([types], data).toArray();
    return decoded[0];
  } catch {
    throw buildError2(
      "decode",
      ABI2.INVALID_DATA_TO_DECODE,
      "Decoding failed: Data must be a valid hex string that encodes a valid ABI type."
    );
  }
}
var abi = {
  ...fragment,
  encode,
  encodeParams,
  decode
};

// src/contract/coder.ts
import { Interface as EthersInterface } from "ethers";
import { ABI as ABI3, buildError as buildError3, ERROR_CODES } from "@vechain/sdk-errors";
function createInterface(abi2) {
  return new EthersInterface(abi2);
}
function encodeFunctionInput(interfaceABI, functionName, functionData) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).encodeInput(functionData);
  } catch (e) {
    throw buildError3(
      "coder.encodeFunctionInput",
      ERROR_CODES.ABI.INVALID_DATA_TO_ENCODE,
      `Method 'encodeFunctionInput' failed while encoding input for function '${functionName}'. Input must match ABI specifications and be correctly formatted.
Parameters: ${JSON.stringify(functionData)}.
Ethers' error message: ${e.message}.`,
      { functionName, functionData },
      e
    );
  }
}
function decodeFunctionInput(interfaceABI, functionName, encodedFunctionInput) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).decodeInput(encodedFunctionInput);
  } catch (e) {
    throw buildError3(
      "coder.decodeFunctionInput",
      ERROR_CODES.ABI.INVALID_DATA_TO_DECODE,
      "Decoding failed: Function input must be properly encoded per ABI specifications.",
      { functionName },
      e
    );
  }
}
function decodeFunctionOutput(interfaceABI, functionName, encodedFunctionOutput) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).decodeOutput(encodedFunctionOutput);
  } catch (e) {
    throw buildError3(
      "coder.decodeFunctionOutput",
      ERROR_CODES.ABI.INVALID_DATA_TO_DECODE,
      "Decoding failed: Function output must be properly encoded per ABI specifications.",
      { functionName },
      e
    );
  }
}
function encodeEventLog(interfaceABI, eventName, dataToEncode) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Event(
      contractInterface.getEvent(eventName)
    ).encodeEventLog(dataToEncode);
  } catch (e) {
    throw buildError3(
      "coder.encodeEventLog",
      ERROR_CODES.ABI.INVALID_EVENT,
      "Encoding failed: Event log data must align with ABI specifications for encoding.",
      { eventName },
      e
    );
  }
}
function decodeEventLog(interfaceABI, eventName, dataToDecode) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Event(
      contractInterface.getEvent(eventName)
    ).decodeEventLog(dataToDecode);
  } catch (e) {
    throw buildError3(
      "coder.decodeEventLog",
      ERROR_CODES.ABI.INVALID_EVENT,
      "Decoding failed: Event log data must be correctly encoded per ABI specifications.",
      { eventName },
      e
    );
  }
}
function parseLog(interfaceABI, data, topics) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return contractInterface.parseLog({ topics, data });
  } catch (e) {
    throw buildError3(
      "coder.parseLog",
      ABI3.INVALID_DATA_TO_DECODE,
      "Decoding failed: Data and topics must be correctly formatted for ABI-compliant decoding.",
      { data },
      e
    );
  }
}
var coder = {
  createInterface,
  encodeFunctionInput,
  decodeFunctionInput,
  decodeFunctionOutput,
  encodeEventLog,
  decodeEventLog,
  parseLog
};

// src/address/address.ts
import { ethers as ethers7 } from "ethers";

// src/utils/const/bloom.ts
var BLOOM_REGEX_UPPERCASE = /^(0x)?[0-9A-F]{16,}$/;
var BLOOM_REGEX_LOWERCASE = /^(0x)?[0-9a-f]{16,}$/;

// src/utils/const/data.ts
var ZERO_BUFFER = (size) => Buffer.alloc(size, 0);
var HEX_REGEX_OPTIONAL_PREFIX = /^(0x)?[0-9a-fA-F]*$/;
var HEX_REGEX = /^0x[0-9a-f]*$/i;
var HEX_ADDRESS_REGEX = /^0x[0-9a-f]{40}$/i;
var DECIMAL_INTEGER_REGEX = /^\d+$/;
var NUMERIC_REGEX = /(^-?\d+(\.\d+)?)$|(^-?\.\d+)$/;
var THOR_ID_LENGTH = 64;

// src/utils/const/hdnode.ts
var VET_DERIVATION_PATH = "m/44'/818'/0'/0";
var X_PUB_PREFIX = Buffer.from("0488b21e000000000000000000", "hex");
var X_PRIV_PREFIX = Buffer.from("0488ade4000000000000000000", "hex");

// src/utils/const/keystore.ts
var SCRYPT_PARAMS = {
  N: 131072,
  r: 8,
  p: 1
};

// src/utils/const/mnemonic.ts
var MNEMONIC_WORDLIST_ALLOWED_SIZES = [
  12,
  15,
  18,
  21,
  24
];

// src/utils/const/secp256k1.ts
var PRIVATE_KEY_MAX_VALUE = Buffer.from(
  "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
  "hex"
);

// src/encoding/rlp/rlp.ts
import { RLP as rlp } from "@ethereumjs/rlp";
import { assert as assert9, RLP as RLPError2 } from "@vechain/sdk-errors";

// src/assertions/account/account.ts
import { assert as assert2, DATA } from "@vechain/sdk-errors";
function assertIsAddress(methodName, address) {
  assert2(
    `assertIsAddress - ${methodName}`,
    addressUtils.isAddress(address),
    DATA.INVALID_DATA_TYPE,
    "Invalid address. The address must be 20 bytes (a 42 characters hex string with a `0x` prefix.)",
    { address }
  );
}

// src/assertions/block/block.ts
import { assert as assert3, DATA as DATA2 } from "@vechain/sdk-errors";
function assertIsRevisionForBlock(methodName, revision) {
  assert3(
    `assertIsRevisionForBlock - ${methodName}`,
    revision === void 0 || revision === null || revisionUtils.isRevisionBlock(revision),
    DATA2.INVALID_DATA_TYPE,
    'Invalid revision. The revision must be a string representing a block number or block id (also "best" is accepted which represents the best block & "finalized" for the finalized block).',
    { revision }
  );
}
function assertIsRevisionForAccount(methodName, revision) {
  assert3(
    `assertIsRevisionForAccount - ${methodName}`,
    revision === void 0 || revision === null || revisionUtils.isRevisionAccount(revision),
    DATA2.INVALID_DATA_TYPE,
    'Invalid revision. The revision must be a string representing a block number or block id (also "best" is accepted which represents the best block).',
    { revision }
  );
}

// src/assertions/hash/hash.ts
import { assert as assert4, DATA as DATA3 } from "@vechain/sdk-errors";
var isValidReturnType = (value) => {
  return !(value !== "buffer" && value !== "hex");
};
function assertIsValidReturnType(methodName, returnType) {
  assert4(
    `assertIsValidReturnType - ${methodName}`,
    isValidReturnType(returnType),
    DATA3.INVALID_DATA_RETURN_TYPE,
    "Validation error: Invalid Return type. Return type in hash function must be 'buffer' or 'hex'.",
    { returnType }
  );
}

// src/assertions/hdnode/hdnode.ts
import { assert as assert5, HDNODE } from "@vechain/sdk-errors";
function assertIsValidHdNodeDerivationPath(methodName, path) {
  assert5(
    "assertIsValidHdNodeDerivationPath",
    isDerivationPathValid(path),
    HDNODE.INVALID_HDNODE_DERIVATION_PATH,
    "Invalid derivation path. Ensure the path adheres to the standard format.",
    { path }
  );
}
function assertIsValidHdNodeChainCode(methodName, chainCode) {
  assert5(
    "assertIsValidHdNodeChainCode",
    chainCode.length === 32,
    HDNODE.INVALID_HDNODE_CHAIN_CODE,
    "Invalid chain code. Length must be exactly 32 bytes.",
    { chainCode }
  );
}

// src/assertions/keystore/keystore.ts
import { assert as assert6, SECP256K1 } from "@vechain/sdk-errors";
function assertIsValidPrivateKey(methodName, privateKey, isValidPrivateKeyFunction) {
  assert6(
    `assertIsValidPrivateKey - ${methodName}`,
    isValidPrivateKeyFunction(privateKey),
    SECP256K1.INVALID_SECP256k1_PRIVATE_KEY,
    "Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.",
    { privateKey }
  );
}
function assertIsValidSecp256k1MessageHash(methodName, msgHash, isValidMessageHashFunction) {
  assert6(
    `assertIsValidSecp256k1MessageHash - ${methodName}`,
    isValidMessageHashFunction(msgHash),
    SECP256K1.INVALID_SECP256k1_MESSAGE_HASH,
    "Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.",
    { msgHash }
  );
}

// src/assertions/transaction/transaction.ts
import { assert as assert7, DATA as DATA4, SECP256K1 as SECP256K12, TRANSACTION } from "@vechain/sdk-errors";
function assertValidTransactionID(methodName, transactionId) {
  assert7(
    `assertValidTransactionID - ${methodName}`,
    dataUtils.isThorId(transactionId, true),
    DATA4.INVALID_DATA_TYPE,
    "Invalid transaction ID given as input. Input must be an hex string of length 64.",
    { transactionId }
  );
}
function assertValidTransactionHead(methodName, head) {
  assert7(
    `assertValidTransactionHead - ${methodName}`,
    head === void 0 || dataUtils.isThorId(head, true),
    DATA4.INVALID_DATA_TYPE,
    "Invalid head given as input. Input must be an hex string of length 64.",
    { head }
  );
}
function assertIsSignedTransaction(methodName, tx) {
  assert7(
    `assertIsSignedTransaction - ${methodName}`,
    tx.isSigned,
    TRANSACTION.NOT_SIGNED,
    "Transaction must be signed.",
    {
      tx
    }
  );
}
function assertIsValidTransactionSigningPrivateKey(methodName, privateKey, isValidPrivateKeyFunction, role) {
  assert7(
    `assertIsValidTransactionSigningPrivateKey - ${methodName}`,
    isValidPrivateKeyFunction(privateKey),
    SECP256K12.INVALID_SECP256k1_PRIVATE_KEY,
    `Invalid ${role} private key used to sign the transaction. Ensure it's a valid secp256k1 private key.`,
    { privateKey }
  );
}
function assertCantGetFieldOnUnsignedTransaction(methodName, transaction, fieldToGet) {
  assert7(
    `assertCantGetFieldOnUnsignedTransaction - ${methodName}`,
    transaction.isSigned,
    TRANSACTION.NOT_SIGNED,
    `Cannot get ${fieldToGet} from unsigned transaction. Sign the transaction first.`
  );
}

// src/assertions/rlp/rlp.ts
import { assert as assert8, RLP as RLPError, RLP } from "@vechain/sdk-errors";
function assertIsValidBuffer(methodName, bufferToCheck, context) {
  assert8(
    `assertIsValidBuffer - ${methodName}`,
    Buffer.isBuffer(bufferToCheck),
    RLP.INVALID_RLP,
    `Validation error: Expected a Buffer type in ${context}.`,
    {
      bufferToCheck,
      context
    }
  );
}
function assertIsArray(methodName, arrayToCheck, context) {
  assert8(
    `assertIsArray - ${methodName}`,
    Array.isArray(arrayToCheck),
    RLPError.INVALID_RLP,
    `Validation error: Expected an array in ${context}.`,
    {
      context
    }
  );
}

// src/encoding/rlp/rlp.ts
function encode2(data) {
  const encodedData = rlp.encode(data);
  return Buffer.from(encodedData);
}
function decode2(encodedData) {
  return rlp.decode(encodedData);
}
var Profiler = class {
  /**
   * Creates a new Profiler instance.
   * @param profile - RLP profile for encoding/decoding structures.
   */
  constructor(profile) {
    this.profile = profile;
  }
  /**
   * Encodes an object following the provided RLP profile.
   * @param data - Object to be encoded.
   * @returns - Encoded data as a Buffer.
   */
  encodeObject(data) {
    const packedData = _packData(data, this.profile, "");
    return Buffer.from(rlp.encode(packedData));
  }
  /**
   * Decodes an object following the provided RLP profile.
   * @param encodedData - Data to be decoded.
   * @returns - Decoded data as RLPValueType.
   */
  decodeObject(encodedData) {
    const packedData = rlp.decode(encodedData);
    return _unpackData(packedData, this.profile, "");
  }
};
var _packData = (obj, profile, context) => {
  context = context !== "" ? context + "." + profile.name : profile.name;
  const kind = profile.kind;
  if (kind instanceof RLP2.ScalarKind) {
    return kind.data(obj, context).encode();
  }
  if (Array.isArray(kind)) {
    return kind.map(
      (k) => _packData(obj[k.name], k, context)
    );
  }
  assertIsArray("packData", obj, context);
  if ("item" in kind && Array.isArray(obj)) {
    const item = kind.item;
    return obj.map(
      (part, i) => _packData(
        part,
        { name: "#" + i, kind: item },
        context
      )
    );
  }
};
var _unpackData = (packed, profile, context) => {
  context = context !== "" ? context + "." + profile.name : profile.name;
  const kind = profile.kind;
  if (kind instanceof RLP2.ScalarKind) {
    assert9(
      "_unpackData",
      Buffer.isBuffer(packed) || packed instanceof Uint8Array,
      RLPError2.INVALID_RLP,
      "Unpacking error: Expected data type is Buffer.",
      { context }
    );
    if (packed instanceof Uint8Array)
      packed = Buffer.from(packed);
    return kind.buffer(packed, context).decode();
  }
  if (Array.isArray(kind) && Array.isArray(packed)) {
    const parts = packed;
    assert9(
      "_unpackData",
      parts.length === kind.length,
      RLPError2.INVALID_RLP,
      `Unpacking error: Expected ${kind.length} items, but got ${parts.length}.`,
      { context }
    );
    return kind.reduce(
      (obj, profile2, index) => {
        obj[profile2.name] = _unpackData(parts[index], profile2, context);
        return obj;
      },
      {}
    );
  }
  assertIsArray("_unpackData", packed, context);
  if ("item" in kind && Array.isArray(packed)) {
    const item = kind.item;
    return packed.map(
      (part, index) => _unpackData(part, { name: "#" + index, kind: item }, context)
    );
  }
};
var RLPBase = { encode: encode2, decode: decode2, Profiler };

// src/encoding/rlp/kind/scalarkind.abstract.ts
var ScalarKind = class {
};

// src/encoding/rlp/kind/bufferkind.ts
var BufferKind = class extends ScalarKind {
  /**
   * Encodes the input data into buffer format.
   *
   * @throws{InvalidRLPError}
   * @param data - The data to encode, expected to be of buffer type.
   * @param context - Descriptive context for error messages
   * @returns DataOutput object with an encode function.
   */
  data(data, context) {
    assertIsValidBuffer("data", data, context);
    return {
      encode: () => data
      // Data is already a Buffer, so return as-is.
    };
  }
  /**
   * Decodes the input buffer.
   *
   * @throws{InvalidRLPError}
   * @param buffer - The buffer to decode, expected to be of buffer type.
   * @param context - Descriptive context for error messages, usually representing the caller's identity.
   * @returns BufferOutput object with a decode function.
   */
  buffer(buffer, context) {
    assertIsValidBuffer("buffer", buffer, context);
    return {
      decode: () => buffer
      // Buffer is already in the correct format, so return as-is.
    };
  }
};

// src/encoding/rlp/helpers/numerickind.ts
import { assert as assert10, RLP as RLP3 } from "@vechain/sdk-errors";
var validateNumericKindData = (data, context) => {
  assert10(
    "validateNumericKindData",
    typeof data === "number" || typeof data === "string",
    RLP3.INVALID_RLP,
    `Validation error: Input in ${context} must be a string or number.`,
    { data, context }
  );
  if (typeof data === "number") {
    _validateNumericKindNumber(data, context);
  } else if (typeof data === "string") {
    _validateNumericKindString(data, context);
  }
  return BigInt(data);
};
var _validateNumericKindNumber = (num, context) => {
  assert10(
    "validateNumericKindNumber",
    Number.isSafeInteger(num) && num >= 0,
    RLP3.INVALID_RLP,
    `Validation error: Number in ${context} must be a safe and non-negative integer.`,
    {
      num,
      context
    }
  );
};
var _validateNumericKindString = (str, context) => {
  const isHex = dataUtils.isHexString(str);
  const isDecimal = dataUtils.isDecimalString(str);
  assert10(
    "_validateNumericKindString",
    isHex || isDecimal,
    RLP3.INVALID_RLP,
    `Validation error: String in ${context} must represent a non-negative integer in hex or decimal format.`,
    { str, context }
  );
  assert10(
    "_validateNumericKindString",
    !isHex || str.length > 2,
    RLP3.INVALID_RLP,
    `Validation error: Hex string number in ${context} must be of valid length.`,
    { str, context }
  );
};
var assertValidNumericKindBuffer = (buf, context, maxBytes) => {
  assert10(
    "assertValidNumericKindBuffer",
    maxBytes === void 0 || buf.length <= maxBytes,
    RLP3.INVALID_RLP,
    `Validation error: Buffer in ${context} must be less than ${maxBytes} bytes.`,
    { maxBytes, context }
  );
  assert10(
    "assertValidNumericKindBuffer",
    buf[0] !== 0,
    RLP3.INVALID_RLP,
    `Validation error: Buffer in ${context} must represent a canonical integer (no leading zeros).`,
    { buf, context }
  );
};
var encodeBigIntToBuffer = (bi, maxBytes, context) => {
  if (bi === 0n)
    return Buffer.alloc(0);
  const hex = Hex.of(bi);
  assert10(
    "encodeBigIntToBuffer",
    maxBytes === void 0 || hex.length <= maxBytes * 2,
    RLP3.INVALID_RLP,
    `Validation error: Encoded number in ${context} must fit within ${maxBytes} bytes.`,
    { maxBytes, hex, context }
  );
  return Buffer.from(hex, "hex");
};
var decodeBufferToNumberOrHex = (buffer) => {
  if (buffer.length === 0)
    return 0;
  const bi = BigInt("0x" + buffer.toString("hex"));
  const num = Number(bi);
  return Number.isSafeInteger(num) ? num : "0x" + bi.toString(16);
};

// src/encoding/rlp/helpers/hexblobkind.ts
import { assert as assert11, RLP as RLP4 } from "@vechain/sdk-errors";
var assertValidHexBlobKindData = (data, context) => {
  assert11(
    "assertValidHexBlobKindData",
    typeof data === "string",
    RLP4.INVALID_RLP,
    "Validation error: Input must be a string.",
    {
      data,
      context
    }
  );
  assert11(
    "assertValidHexBlobKindData",
    dataUtils.isHexString(data, true),
    RLP4.INVALID_RLP,
    "Validation error: Input must be a valid hex string with a '0x' prefix.",
    { data, context }
  );
  assert11(
    "assertValidHexBlobKindData",
    data.length % 2 === 0,
    RLP4.INVALID_RLP,
    "Validation error: Hex string must have an even length.",
    { data, context }
  );
};
var assertValidHexBlobKindBuffer = (buffer, context) => {
  assert11(
    "assertValidHexBlobKindBuffer",
    Buffer.isBuffer(buffer),
    RLP4.INVALID_RLP,
    "Validation error: Input must be a valid buffer.",
    {
      buffer,
      context
    }
  );
};

// src/encoding/rlp/helpers/fixedhexblobkind.ts
import { assert as assert12, RLP as RLP5 } from "@vechain/sdk-errors";
var assertFixedHexBlobKindData = (data, context, bytes) => {
  assert12(
    "assertFixedHexBlobKindData",
    data.length === bytes * 2 + 2,
    RLP5.INVALID_RLP,
    `Validation error: Hex string in ${context} must be exactly ${bytes} bytes in length.`,
    { data, context }
  );
};
var assertFixedHexBlobKindBuffer = (buffer, context, bytes) => {
  assert12(
    "assertFixedHexBlobKindBuffer",
    buffer.length === bytes,
    RLP5.INVALID_RLP,
    `Validation error: Buffer in ${context} must be exactly ${bytes} bytes in length.`,
    { buffer, context }
  );
};

// src/encoding/rlp/helpers/compactfixedhexblobkind.ts
import { assert as assert13, RLP as RLP6 } from "@vechain/sdk-errors";
var assertCompactFixedHexBlobBuffer = (buffer, context, bytes) => {
  assert13(
    "assertCompactFixedHexBlobBuffer",
    buffer.length <= bytes,
    RLP6.INVALID_RLP,
    `Validation error: Buffer in ${context} must be at most ${bytes} bytes.`,
    { buffer, context }
  );
  assert13(
    "assertCompactFixedHexBlobBuffer",
    buffer.length === 0 || buffer[0] !== 0,
    RLP6.INVALID_RLP,
    `Validation error: Buffer in ${context} should not have leading zero bytes.`,
    {
      buffer,
      context
    }
  );
};
var encodeCompactFixedHexBlob = (buffer) => {
  const zeroIndex = buffer.findIndex((byte) => byte !== 0);
  return zeroIndex !== -1 ? buffer.subarray(zeroIndex) : Buffer.alloc(0);
};
var decodeBufferToHexWithLeadingZeros = (buffer, bytes) => {
  return Hex.of0x(buffer, bytes);
};

// src/encoding/rlp/kind/numerickind.ts
var NumericKind = class extends ScalarKind {
  /**
   * Constructs a new instance of NumericKind.
   *
   * @param maxBytes - Optional parameter that specifies the maximum number of bytes that numeric data can occupy when encoded.
   */
  constructor(maxBytes) {
    super();
    this.maxBytes = maxBytes;
  }
  /**
   * Encodes the input data into numeric format and ensures it doesn't exceed the maximum bytes, if specified.
   *
   * @param data - The data to encode, expected to be numeric.
   * @param context - Descriptive context for error messages
   * @returns DataOutput object with an encode function.
   * @throws Will throw an error if data validation fails or encoding issues occur.
   */
  data(data, context) {
    const dataBI = validateNumericKindData(data, context);
    return {
      encode: () => encodeBigIntToBuffer(dataBI, this.maxBytes, context)
      // Encodes BigInt to Buffer, respecting maxBytes.
    };
  }
  /**
   * Decodes the input buffer into a number or hexadecimal string, ensuring it meets numeric data constraints.
   *
   * @param buffer - The buffer to decode, containing numeric data.
   * @param context - Descriptive context for error messages.
   * @returns BufferOutput object with a decode function.
   * @throws Will throw an error if buffer validation fails.
   */
  buffer(buffer, context) {
    assertValidNumericKindBuffer(buffer, context, this.maxBytes);
    return {
      decode: () => decodeBufferToNumberOrHex(buffer)
      // Decodes buffer to either a number or a hexadecimal string.
    };
  }
};

// src/encoding/rlp/kind/hexblobkinds/hexblob.ts
var HexBlobKind = class extends ScalarKind {
  /**
   * Encodes the input data into a Buffer.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    assertValidHexBlobKindData(data, context);
    return {
      encode: () => Buffer.from(data.slice(2), "hex")
    };
  }
  /**
   * Decodes the input buffer into a hex string.
   *
   * @param buffer - The buffer to decode.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string.
   */
  buffer(buffer, context) {
    assertValidHexBlobKindBuffer(buffer, context);
    return {
      decode: () => Hex.of0x(buffer)
    };
  }
};

// src/encoding/rlp/kind/hexblobkinds/fixedhexblob.ts
var FixedHexBlobKind = class extends HexBlobKind {
  /**
   * Creates a new instance of the {@link FixedHexBlobKind} class.
   * @param bytes - The number of bytes the blob must have.
   */
  constructor(bytes) {
    super();
    this.bytes = bytes;
  }
  /**
   * Encodes the input data into a Buffer with validation against fixed size.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    const encoder = super.data(data, context);
    assertFixedHexBlobKindData(data, context, this.bytes);
    return encoder;
  }
  /**
   * Decodes the input buffer into a hex string with validation against fixed size.
   *
   * @param buffer - The buffer to decode.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string.
   */
  buffer(buffer, context) {
    const decoder = super.buffer(buffer, context);
    assertFixedHexBlobKindBuffer(buffer, context, this.bytes);
    return decoder;
  }
};

// src/encoding/rlp/kind/hexblobkinds/optionalfixedhexblob.ts
var OptionalFixedHexBlobKind = class extends FixedHexBlobKind {
  /**
   * Encodes the input data (which can be null or undefined) into a Buffer.
   *
   * @param data - The data to encode, can be null or undefined.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    return data == null ? {
      encode: () => Buffer.alloc(0)
    } : super.data(data, context);
  }
  /**
   * Decodes the input buffer into a hex string or null if the buffer is empty.
   *
   * @param buffer - The buffer to decode, can be empty.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string or null.
   */
  buffer(buffer, context) {
    return buffer.length === 0 ? {
      decode: () => null
    } : super.buffer(buffer, context);
  }
};

// src/encoding/rlp/kind/hexblobkinds/compactfixedhexblob.ts
var CompactFixedHexBlobKind = class extends FixedHexBlobKind {
  /**
   * Encodes the input data into a Buffer, trimming leading zeros.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    const buffer = super.data(data, context).encode();
    return {
      encode: () => encodeCompactFixedHexBlob(buffer)
      // Encode the buffer, trimming leading zeros.
    };
  }
  /**
   * Decodes the input buffer into a number or hexadecimal string, ensuring it meets the fixed size by padding with zeros.
   *
   * @param buffer - The buffer to decode, containing numeric data.
   * @param context - Descriptive context for error messages, usually representing the caller's identity.
   * @returns BufferOutput object with a decode function.
   * @throws Will throw an error if buffer validation fails.
   */
  buffer(buffer, context) {
    assertCompactFixedHexBlobBuffer(buffer, context, this.bytes);
    return {
      decode: () => Hex.of0x(buffer, this.bytes)
      // Decode the buffer, returning a hex string with leading zeros.
    };
  }
};

// src/encoding/rlp/kind/index.ts
var RLPProfiles = {
  ScalarKind,
  BufferKind,
  NumericKind,
  HexBlobKind,
  FixedHexBlobKind,
  OptionalFixedHexBlobKind,
  CompactFixedHexBlobKind
};

// src/encoding/rlp/index.ts
var RLP2 = {
  ...RLPBase,
  ...RLPProfiles
};

// src/utils/const/transaction.ts
var TRANSACTIONS_GAS_CONSTANTS = {
  /**
   * Default gas for a transaction
   * @internal
   */
  TX_GAS: 5e3,
  /**
   * Default gas for a clause
   * @internal
   */
  CLAUSE_GAS: 16e3,
  /**
   * Default gas for a contract creation clause
   * @internal
   */
  CLAUSE_GAS_CONTRACT_CREATION: 48e3,
  /**
   * Zero gas data
   * @internal
   */
  ZERO_GAS_DATA: 4,
  /**
   * Non-zero gas data
   * @internal
   */
  NON_ZERO_GAS_DATA: 68
};
var TRANSACTION_FIELDS = [
  /**
   * Chain tag. It represents the id of the chain the transaction is sent to.
   */
  { name: "chainTag", kind: new RLP2.NumericKind(1) },
  /**
   * Block reference. It represents the last block of the chain the transaction is sent to.
   */
  {
    name: "blockRef",
    kind: new RLP2.CompactFixedHexBlobKind(8)
  },
  /**
   * Expiration. It represents the expiration date of the transaction.
   */
  { name: "expiration", kind: new RLP2.NumericKind(4) },
  /**
   * Clauses of the transaction. They represent the actions to be executed by the transaction.
   */
  {
    name: "clauses",
    kind: {
      item: [
        { name: "to", kind: new RLP2.OptionalFixedHexBlobKind(20) },
        { name: "value", kind: new RLP2.NumericKind(32) },
        { name: "data", kind: new RLP2.HexBlobKind() }
      ]
    }
  },
  /**
   * Gas price coef. It represents the gas price coefficient of the transaction.
   */
  { name: "gasPriceCoef", kind: new RLP2.NumericKind(1) },
  /**
   * Gas. It represents the gas limit of the transaction.
   */
  { name: "gas", kind: new RLP2.NumericKind(8) },
  /**
   * Depends on. It represents the hash of the transaction the current transaction depends on.
   */
  { name: "dependsOn", kind: new RLP2.OptionalFixedHexBlobKind(32) },
  /**
   * Nonce. It represents the nonce of the transaction.
   */
  { name: "nonce", kind: new RLP2.NumericKind(8) },
  /**
   * Reserved. It represents the reserved field of the transaction.
   */
  { name: "reserved", kind: { item: new RLP2.BufferKind() } }
];
var TRANSACTION_FEATURES_KIND = {
  name: "reserved.features",
  kind: new RLP2.NumericKind(4)
};
var TRANSACTION_SIGNATURE_KIND = {
  name: "signature",
  kind: new RLP2.BufferKind()
};
var UNSIGNED_TRANSACTION_RLP = new RLP2.Profiler({
  name: "tx",
  kind: TRANSACTION_FIELDS
});
var SIGNED_TRANSACTION_RLP = new RLP2.Profiler({
  name: "tx",
  // Add signature to the transaction fields
  kind: TRANSACTION_FIELDS.concat([TRANSACTION_SIGNATURE_KIND])
});
var SIGNATURE_LENGTH = 65;
var BLOCK_REF_LENGTH = 8;

// src/utils/const/abi.ts
var PARAMS_ABI = JSON.stringify([
  {
    constant: false,
    inputs: [
      {
        name: "_key",
        type: "bytes32"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "set",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_key",
        type: "bytes32"
      }
    ],
    name: "get",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "executor",
    outputs: [
      {
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "key",
        type: "bytes32"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Set",
    type: "event"
  }
]);
var VIP180_ABI = JSON.stringify([
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "move",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalBurned",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "remaining",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        name: "_value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        name: "_spender",
        type: "address"
      },
      {
        indexed: false,
        name: "_value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  }
]);
var ERC721_ABI = JSON.stringify([
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ERC721IncorrectOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ERC721InsufficientApproval",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address"
      }
    ],
    name: "ERC721InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "ERC721InvalidOperator",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ERC721InvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "ERC721InvalidReceiver",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ERC721InvalidSender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ERC721NonexistentToken",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "mintItem",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
]);

// src/hash/blake2b256.ts
import blake from "blakejs";
function _blake2b256(...data) {
  const ctx = blake.blake2bInit(32);
  data.forEach((d) => {
    if (Buffer.isBuffer(d)) {
      blake.blake2bUpdate(ctx, d);
    } else {
      blake.blake2bUpdate(ctx, Buffer.from(d, "utf8"));
    }
  });
  return Buffer.from(blake.blake2bFinal(ctx));
}
function blake2b256(data, returnType = "buffer") {
  assertIsValidReturnType("blake2b256", returnType);
  const dataBytesLike = [data];
  const hash2 = _blake2b256(...dataBytesLike);
  return returnType === "buffer" ? hash2 : Hex.of0x(hash2);
}

// src/hash/sha256.ts
import { ethers as ethers3 } from "ethers";
function sha256(data, returnType = "buffer") {
  assertIsValidReturnType("sha256", returnType);
  const hash2 = ethers3.isBytesLike(data) ? ethers3.sha256(data) : ethers3.sha256(ethers3.toUtf8Bytes(data));
  return returnType === "buffer" ? Buffer.from(hash2.slice(2), "hex") : hash2;
}

// src/hash/keccak256.ts
import { ethers as ethers4 } from "ethers";
function keccak256(data, returnType = "buffer") {
  assertIsValidReturnType("keccak256", returnType);
  const hash2 = ethers4.isBytesLike(data) ? ethers4.keccak256(data) : ethers4.keccak256(ethers4.toUtf8Bytes(data));
  return returnType === "buffer" ? Buffer.from(hash2.slice(2), "hex") : hash2;
}

// src/bloom/bloom.ts
import { Buffer as Buffer2 } from "buffer";
var Filter = class {
  bits;
  k;
  /**
   * Constructs a new Filter instance.
   * @param bits - The bit array used in the Bloom filter.
   * @param k - The number of hash functions to be used.
   */
  constructor(bits, k) {
    this.bits = bits;
    this.k = k;
  }
  /**
   * Checks if the given key might be contained in the set.
   * Note: false positives are possible, but false negatives are not.
   * @param key - The key to be checked.
   * @returns A boolean indicating whether the key might be contained in the set.
   */
  contains(key) {
    return distribute(
      hash(key),
      this.k,
      this.bits.byteLength * 8,
      (index, bit) => {
        return (this.bits[index] & bit) === bit;
      }
    );
  }
};
function addWithUInt32Wrap(a, b) {
  return (a + b) % 2 ** 32;
}
function hash(key) {
  const uint8ArrayKey = new Uint8Array(key);
  const hash2 = blake2b256(uint8ArrayKey);
  return hash2.readUInt32BE(0);
}
function distribute(hash2, k, nBits, cb) {
  const delta = (hash2 >>> 17 | hash2 << 15) >>> 0;
  for (let i = 0; i < k; i++) {
    const bitPos = hash2 % nBits;
    if (!cb(Math.floor(bitPos / 8), 1 << bitPos % 8)) {
      return false;
    }
    hash2 = addWithUInt32Wrap(hash2, delta);
  }
  return true;
}
var Generator = class {
  hashes = /* @__PURE__ */ new Map();
  /**
   * Adds a key to the generator's internal map for later Bloom filter generation.
   * @param key - The key to be added.
   */
  add(key) {
    this.hashes.set(hash(key), true);
  }
  /**
   * Generates a variable-length Bloom filter based on the bits per key and count of keys.
   * The generator will be reset after generation.
   *
   * @param bitsPerKey - The number of bits per key.
   * @param k - The number of hash functions to be used (count of keys).
   * @returns A new Filter instance.
   */
  generate(bitsPerKey, k) {
    let nBytes = Math.floor((this.hashes.size * bitsPerKey + 7) / 8);
    nBytes = nBytes < 8 ? 8 : nBytes;
    const bits = Buffer2.alloc(nBytes);
    const nBits = nBytes * 8;
    for (const hash2 of this.hashes.keys()) {
      distribute(hash2, k, nBits, (index, bit) => {
        bits[index] |= bit;
        return true;
      });
    }
    this.hashes.clear();
    return new Filter(bits, k);
  }
};
function calculateK(bitsPerKey) {
  const k = Math.floor(bitsPerKey * 69 / 100);
  if (k < 1)
    return 1;
  return k > 30 ? 30 : k;
}
var bloom = {
  Generator,
  Filter,
  calculateK
};

// src/utils/data/data.ts
import { ethers as ethers5 } from "ethers";
import { assert as assert15, buildError as buildError4, DATA as DATA6 } from "@vechain/sdk-errors";
import * as crypto from "crypto";

// src/utils/hex/Hex.ts
import { assert as assert14, DATA as DATA5 } from "@vechain/sdk-errors";
import { Buffer as Buffer3 } from "buffer";
var ENCODING = "hex";
var PREFIX = "0x";
var RADIX = 16;
function ofBigInt(bi, bytes) {
  assert14(
    "Hex.ofBigInt",
    bi >= 0,
    DATA5.INVALID_DATA_TYPE,
    "Arg 'n' not negative." /* NOT_POSITIVE */,
    {
      bi: bi.toString()
    }
  );
  return pad(bi.toString(RADIX), bytes);
}
function ofBuffer(buffer, bytes = 0) {
  return pad(Buffer3.from(buffer).toString(ENCODING), bytes);
}
function ofNumber(n, bytes) {
  assert14(
    "Hex.ofNumber",
    Number.isInteger(n),
    DATA5.INVALID_DATA_TYPE,
    "Arg 'n' not an integer." /* NOT_INTEGER */,
    {
      n
    }
  );
  assert14(
    "Hex.ofNumber",
    n >= 0,
    DATA5.INVALID_DATA_TYPE,
    "Arg 'n' not negative." /* NOT_POSITIVE */,
    {
      n
    }
  );
  return pad(n.toString(RADIX), bytes);
}
function ofString(txt, bytes) {
  return pad(Buffer3.from(txt).toString(ENCODING), bytes);
}
function pad(exp, bytes) {
  if (exp.length % 2 !== 0) {
    exp = "0" + exp;
  }
  if (bytes > 0) {
    const gap = bytes - exp.length / 2;
    if (gap > 0) {
      return `${"00".repeat(gap)}${exp}`;
    }
  }
  return exp;
}
var Hex = {
  /**
   * Generate a hexadecimal representation from the given input data.
   * This method calls
   * * {@link ofBigInt} if `n` type is `bigint`;
   * * {@link ofNumber} if `n` type is `number`;
   * * {@link ofString} if `n` type is `string`;
   * * {@link ofBuffer} if `n` is an instance of {@link Uint8Array}.
   *
   * **Note:** the returned string is not prefixed with `0x`,
   * see {@link Hex.of0x} to make a hexadecimal representation prefixed with `0x`.
   *
   * @param {bigint | Uint8Array | number | string} n - The input data to be represented.
   * @param {number} [bytes=0] - If not `0` by default, the hexadecimal representation encodes at least {number}  bytes.
   * @returns {Uint8Array} - The resulting hexadecimal representation,
   * it is guaranteed to be even characters long.
   */
  of: function(n, bytes = 0) {
    if (typeof n === "bigint")
      return ofBigInt(n, bytes);
    if (typeof n === "number")
      return ofNumber(n, bytes);
    if (typeof n === "string")
      return ofString(n, bytes);
    return ofBuffer(n, bytes);
  },
  /**
   * Generate a hexadecimal representation from the given input data prefixed with `0x`.
   *
   * **Note:** this method calls {@link Hex.of} to generate the hexadecimal representation of n,
   * then it prefixes the result with `0x`.
   *
   * @param {bigint | Uint8Array | number | string} n - The input data to be represented.
   * @param {number} [bytes=0] - If not `0` by default, the hexadecimal representation encodes at least {number}  bytes.
   * @returns {Uint8Array} - The resulting hexadecimal representation,
   * it is guaranteed to be even characters long.
   */
  of0x: function(n, bytes = 0) {
    return `${PREFIX}${this.of(n, bytes)}`;
  }
};

// src/utils/data/data.ts
var toHexString = (data, config) => {
  return config?.withPrefix === true ? Hex.of0x(data) : Hex.of(data);
};
var isHexString = (data, checkPrefix = true) => {
  return checkPrefix ? HEX_REGEX.test(data) : HEX_REGEX_OPTIONAL_PREFIX.test(data);
};
function padHexString(hexString, hexTargetLength = 64) {
  if (!Number.isInteger(hexTargetLength)) {
    throw buildError4(
      "padHexString",
      DATA6.INVALID_DATA_TYPE,
      `The target length '${hexTargetLength}' must be an integer.`,
      { hexTargetLength }
    );
  }
  if (hexString.replace(/^0x/, "").length > hexTargetLength) {
    throw buildError4(
      "padHexString",
      DATA6.INVALID_DATA_TYPE,
      `The input string '${hexString}' is longer than the target length '${hexTargetLength}'.`,
      { hexString, hexTargetLength }
    );
  }
  if (hexString.startsWith("0x")) {
    hexString = hexString.slice(2);
  }
  return "0x" + hexString.padStart(hexTargetLength, "0");
}
var isDecimalString = (data) => {
  return DECIMAL_INTEGER_REGEX.test(data);
};
var removePrefix = (hex) => {
  if (hex.startsWith("0x")) {
    return hex.slice(2);
  }
  return hex;
};
var isNumeric = (value) => {
  return NUMERIC_REGEX.test(value);
};
var isThorId = (data, checkPrefix = false) => {
  return isHexString(data, checkPrefix) && (checkPrefix ? data.length === THOR_ID_LENGTH + 2 : data.length === THOR_ID_LENGTH);
};
var encodeBytes32String = (value, zeroPadding = "left") => {
  try {
    const valueInBytes = ethers5.toUtf8Bytes(value);
    return zeroPadding === "left" ? ethers5.zeroPadValue(valueInBytes, 32) : ethers5.zeroPadBytes(valueInBytes, 32);
  } catch (e) {
    throw buildError4(
      "encodeBytes32String",
      DATA6.INVALID_DATA_TYPE,
      `Encoding to bytes32 failed: Value '${value}' exceeds 32 bytes or is otherwise invalid.`,
      { value, zeroPadding },
      e
    );
  }
};
var decodeBytes32String = (value) => {
  assert15(
    "decodeBytes32String",
    isHexString(value) && removePrefix(value).length === 64,
    DATA6.INVALID_DATA_TYPE,
    `Failed to decode value ${value} to string. Value is not a valid hex string or it is not 64 characters long`,
    { value }
  );
  const valueInBytes = Buffer.from(removePrefix(value), "hex");
  const firstZeroIndex = valueInBytes.findIndex((byte) => byte === 0);
  if (firstZeroIndex === 0) {
    const nonZeroIndex = valueInBytes.findIndex((byte) => byte !== 0);
    return ethers5.toUtf8String(valueInBytes.subarray(nonZeroIndex));
  } else if (firstZeroIndex !== -1) {
    return ethers5.toUtf8String(valueInBytes.subarray(0, firstZeroIndex));
  } else {
    return ethers5.toUtf8String(valueInBytes);
  }
};
var generateRandomHexOfLength = (stringLength) => {
  const bytes = Math.ceil(stringLength / 2);
  return Hex.of(crypto.randomBytes(bytes)).substring(0, stringLength);
};
var dataUtils = {
  toHexString,
  isHexString,
  padHexString,
  removePrefix,
  isDecimalString,
  isNumeric,
  isThorId,
  encodeBytes32String,
  decodeBytes32String,
  generateRandomHexOfLength
};

// src/utils/bloom/bloom.ts
import { ADDRESS, assert as assert16, BLOOM, DATA as DATA7 } from "@vechain/sdk-errors";
var isBloom = (bloom2) => {
  if (typeof bloom2 !== "string") {
    return false;
  }
  return BLOOM_REGEX_LOWERCASE.test(bloom2) || BLOOM_REGEX_UPPERCASE.test(bloom2);
};
var isInBloom = (bloom2, k, data) => {
  assert16(
    "isInBloom",
    isBloom(bloom2),
    BLOOM.INVALID_BLOOM,
    "Invalid bloom filter format. Bloom filters must adhere to the format 0x[0-9a-fA-F]{16,}.",
    { bloom: bloom2 }
  );
  assert16(
    "isInBloom",
    dataUtils.isHexString(data, false),
    DATA7.INVALID_DATA_TYPE,
    "Invalid data type. Data should be an hexadecimal string",
    { data }
  );
  assert16(
    "isInBloom",
    Number.isInteger(k) && k > 0,
    BLOOM.INVALID_K,
    "Invalid k. It should be a positive integer.",
    { k }
  );
  assert16(
    "isInBloom",
    typeof data === "string",
    DATA7.INVALID_DATA_TYPE,
    "Invalid data type. Data should be a string",
    { data }
  );
  const dataBuffer = Buffer.from(dataUtils.removePrefix(data), "hex");
  const bloomBuffer = Buffer.from(dataUtils.removePrefix(bloom2), "hex");
  const bloomFilter = new bloom.Filter(bloomBuffer, k);
  return bloomFilter.contains(dataBuffer);
};
var isAddressInBloom = (bloom2, k, addressToCheck) => {
  assert16(
    "isAddressInBloom",
    addressUtils.isAddress(addressToCheck),
    ADDRESS.INVALID_ADDRESS,
    "Invalid address given as input in Bloom filter. Ensure it is a valid vechain thor address.",
    { addressToCheck }
  );
  return isInBloom(bloom2, k, addressToCheck);
};
var bloomUtils = { isBloom, isInBloom, isAddressInBloom };

// src/utils/hdnode/hdnode.ts
function _checkDerivationPathSingleComponentValid(component, index) {
  return (
    // m
    (index === 0 ? component === "m" : false) || // "number"
    DECIMAL_INTEGER_REGEX.test(component) || // "number'"
    DECIMAL_INTEGER_REGEX.test(component.slice(0, -1)) && component.endsWith("'")
  );
}
function isDerivationPathValid(derivationPath) {
  const pathComponents = derivationPath.split("/");
  for (let i = 0; i < pathComponents.length; i++) {
    if (!_checkDerivationPathSingleComponentValid(pathComponents[i], i))
      return false;
  }
  return true;
}

// src/utils/transaction/transaction.ts
import { assert as assert17, DATA as DATA8 } from "@vechain/sdk-errors";
function intrinsicGas(clauses) {
  if (clauses.length === 0) {
    return TRANSACTIONS_GAS_CONSTANTS.TX_GAS + TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS;
  }
  return clauses.reduce((sum, clause) => {
    if (clause.to !== null) {
      assert17(
        "intrinsicGas",
        addressUtils.isAddress(clause.to),
        DATA8.INVALID_DATA_TYPE,
        `Invalid data type in clause. Each 'to' field must be a valid address.`,
        { clause }
      );
      sum += TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS;
    } else {
      sum += TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS_CONTRACT_CREATION;
    }
    sum += _calculateDataUsedGas(clause.data);
    return sum;
  }, TRANSACTIONS_GAS_CONSTANTS.TX_GAS);
}
function _calculateDataUsedGas(data) {
  assert17(
    "_calculateDataUsedGas",
    data === "" || dataUtils.isHexString(data),
    DATA8.INVALID_DATA_TYPE,
    "Invalid data type for gas calculation. Data should be a hexadecimal string.",
    { data }
  );
  let sum = 0;
  for (let i = 2; i < data.length; i += 2) {
    if (data.substring(i, i + 2) === "00") {
      sum += TRANSACTIONS_GAS_CONSTANTS.ZERO_GAS_DATA;
    } else {
      sum += TRANSACTIONS_GAS_CONSTANTS.NON_ZERO_GAS_DATA;
    }
  }
  return sum;
}
var TransactionUtils = { intrinsicGas };

// src/utils/units/units.ts
import { ethers as ethers6 } from "ethers";
import { assert as assert18, DATA as DATA9 } from "@vechain/sdk-errors";
var parseUnits = (value, decimals) => {
  assert18(
    "parseUnits",
    typeof value !== "string" || dataUtils.isNumeric(value),
    DATA9.INVALID_DATA_TYPE,
    `Invalid value format. The value "${value}" must be a numeric string.`,
    { value }
  );
  return ethers6.parseUnits(value, decimals);
};
var formatUnits = (value, decimals) => {
  return ethers6.formatUnits(value, decimals);
};
var parseVET = (value) => {
  return parseUnits(value, 18);
};
var formatVET = (value) => {
  return formatUnits(value, 18);
};
var unitsUtils = {
  parseUnits,
  formatUnits,
  parseVET,
  formatVET
};

// src/utils/revision/revision.ts
var isRevisionBlock = (revision) => {
  return revision === "finalized" || isRevisionAccount(revision);
};
var isRevisionAccount = (revision) => {
  return revision === "best" || typeof revision === "string" && dataUtils.isHexString(revision) || typeof revision === "string" && dataUtils.isDecimalString(revision) || typeof revision === "number" && revision >= 0;
};
var revisionUtils = { isRevisionBlock, isRevisionAccount };

// src/address/address.ts
import { ADDRESS as ADDRESS2, assert as assert20 } from "@vechain/sdk-errors";

// src/secp256k1/secp256k1.ts
import { randomBytes as randomBytes2 } from "crypto";
import { ec as EC } from "elliptic";
import { assert as assert19, SECP256K1 as SECP256K13 } from "@vechain/sdk-errors";
var curve = new EC("secp256k1");
function isValidMessageHash(hash2) {
  return Buffer.isBuffer(hash2) && hash2.length === 32;
}
function isValidPrivateKey(key) {
  return Buffer.isBuffer(key) && key.length === 32 && !key.equals(ZERO_BUFFER(32)) && key.compare(PRIVATE_KEY_MAX_VALUE) < 0;
}
function generatePrivateKey(entropy) {
  entropy = entropy ?? (() => randomBytes2(32));
  let privateKey;
  do {
    privateKey = entropy();
  } while (!isValidPrivateKey(privateKey));
  return privateKey;
}
function derivePublicKey(privateKey) {
  assertIsValidPrivateKey("derivePublicKey", privateKey, isValidPrivateKey);
  const keyPair = curve.keyFromPrivate(privateKey);
  return Buffer.from(keyPair.getPublic().encode("array", false));
}
function sign(messageHash, privateKey) {
  assertIsValidSecp256k1MessageHash("sign", messageHash, isValidMessageHash);
  assertIsValidPrivateKey("sign", privateKey, isValidPrivateKey);
  const keyPair = curve.keyFromPrivate(privateKey);
  const sig = keyPair.sign(messageHash, { canonical: true });
  const r = Buffer.from(sig.r.toArray("be", 32));
  const s = Buffer.from(sig.s.toArray("be", 32));
  return Buffer.concat([r, s, Buffer.from([sig.recoveryParam])]);
}
function recover(messageHash, sig) {
  assertIsValidSecp256k1MessageHash(
    "recover",
    messageHash,
    isValidMessageHash
  );
  assert19(
    "recover",
    Buffer.isBuffer(sig) && sig.length === SIGNATURE_LENGTH,
    SECP256K13.INVALID_SECP256k1_SIGNATURE,
    "Invalid signature given as input. Length must be exactly 65 bytes.",
    { sig }
  );
  const recovery = sig[64];
  assert19(
    "recover",
    recovery === 0 || recovery === 1,
    SECP256K13.INVALID_SECP256k1_SIGNATURE_RECOVERY,
    "Invalid signature recovery value. Signature bytes at position 64 must be 0 or 1.",
    { recovery }
  );
  const rCopy = Uint8Array.from(sig);
  const r = rCopy.slice(0, 32);
  const sCopy = Uint8Array.from(sig);
  const s = sCopy.slice(32, 64);
  return Buffer.from(
    curve.recoverPubKey(messageHash, { r, s }, recovery).encode("array", false)
  );
}
function extendedPublicKeyToArray(extendedPublicKey, compact) {
  return curve.keyFromPublic(extendedPublicKey).getPublic(compact, "array");
}
var secp256k1 = {
  isValidMessageHash,
  isValidPrivateKey,
  generatePrivateKey,
  derivePublicKey,
  sign,
  recover,
  extendedPublicKeyToArray
};

// src/address/address.ts
function fromPublicKey(publicKey) {
  return ethers7.computeAddress("0x" + publicKey.toString("hex"));
}
function fromPrivateKey(privateKey) {
  return addressUtils.fromPublicKey(secp256k1.derivePublicKey(privateKey));
}
function isAddress(addressToVerify) {
  return HEX_ADDRESS_REGEX.test(addressToVerify);
}
function toChecksummed(address) {
  assert20(
    "toChecksummed",
    isAddress(address),
    ADDRESS2.INVALID_ADDRESS,
    "Checksum failed: Input must be a valid Vechain Thor address.",
    { address }
  );
  return ethers7.getAddress(address);
}
var addressUtils = {
  fromPublicKey,
  fromPrivateKey,
  isAddress,
  toChecksummed
};

// src/certificate/certificate.ts
var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify());
import { Buffer as Buffer4 } from "buffer";
import { assert as assert21, CERTIFICATE } from "@vechain/sdk-errors";
function encode3(cert) {
  return (0, import_fast_json_stable_stringify.default)({
    ...cert,
    signer: cert.signer,
    signature: cert.signature
  });
}
function verify(cert) {
  assert21(
    "verify",
    cert.signature !== void 0 && cert.signature !== null,
    CERTIFICATE.CERTIFICATE_NOT_SIGNED,
    "Verification failed: Certificate's signature is missing.",
    { cert }
  );
  assert21(
    "verify",
    dataUtils.isHexString(cert.signature) && cert.signature.length % 2 === 0,
    CERTIFICATE.CERTIFICATE_INVALID_SIGNATURE_FORMAT,
    "Verification failed: Signature format is invalid.",
    { cert }
  );
  const encoded = encode3({ ...cert, signature: void 0 });
  const signingHash = blake2b256(encoded);
  const pubKey = secp256k1.recover(
    signingHash,
    Buffer4.from(cert.signature.slice(2), "hex")
  );
  assert21(
    "verify",
    addressUtils.fromPublicKey(pubKey) === cert.signer,
    CERTIFICATE.CERTIFICATE_INVALID_SIGNER,
    "Verification failed: Signature does not correspond to the signer's public key.",
    { pubKey, cert }
  );
}
var certificate = { encode: encode3, verify };

// src/clause/clause.ts
import { isAddress as isAddress2 } from "ethers";
import { assert as assert22, buildError as buildError5, DATA as DATA10 } from "@vechain/sdk-errors";
function deployContract(contractBytecode, deployParams) {
  let encodedParams = "";
  if (deployParams != null) {
    encodedParams = abi.encodeParams(deployParams.types, deployParams.values).replace("0x", "");
  }
  return {
    to: null,
    value: 0,
    data: contractBytecode + encodedParams
  };
}
function functionInteraction(contractAddress, functionFragment, args) {
  return {
    to: contractAddress,
    value: 0,
    data: new abi.Function(functionFragment).encodeInput(args)
  };
}
function transferToken(tokenAddress, recipientAddress, amount) {
  try {
    return functionInteraction(
      tokenAddress,
      coder.createInterface(VIP180_ABI).getFunction("transfer"),
      [recipientAddress, BigInt(amount)]
    );
  } catch (error) {
    throw buildError5(
      "transferToken",
      DATA10.INVALID_DATA_TYPE,
      `Invalid 'amount' parameter. Expected an integer but received ${amount}.`
    );
  }
}
function transferVET(recipientAddress, amount) {
  try {
    const bnAmount = BigInt(amount);
    assert22(
      "transferVET",
      bnAmount > 0,
      DATA10.INVALID_DATA_TYPE,
      `Invalid 'amount' parameter. Expected a positive amount but received ${amount}.`
    );
    return {
      to: recipientAddress,
      value: `0x${BigInt(amount).toString(16)}`,
      data: "0x"
    };
  } catch (error) {
    throw buildError5(
      "transferVET",
      DATA10.INVALID_DATA_TYPE,
      `Invalid 'amount' parameter. Expected an integer but received ${amount}.`
    );
  }
}
function transferNFT(contractAddress, senderAddress, recipientAddress, tokenId) {
  assert22(
    "transferNFT",
    tokenId !== "",
    DATA10.INVALID_DATA_TYPE,
    `Invalid 'tokenId' parameter. Expected an id but received ${tokenId}.`
  );
  assert22(
    "transferNFT",
    isAddress2(contractAddress),
    DATA10.INVALID_DATA_TYPE,
    `Invalid 'contractAddress' parameter. Expected a contract address but received ${contractAddress}.`
  );
  return functionInteraction(
    contractAddress,
    coder.createInterface(ERC721_ABI).getFunction("transferFrom"),
    [senderAddress, recipientAddress, tokenId]
  );
}
var clauseBuilder = {
  deployContract,
  functionInteraction,
  transferToken,
  transferVET,
  transferNFT
};

// src/hdnode/hdnode.ts
import { ethers as ethers8 } from "ethers";
import { assert as assert23, HDNODE as HDNODE2 } from "@vechain/sdk-errors";
function fromMnemonic(words, path = VET_DERIVATION_PATH) {
  assert23(
    "fromMnemonic",
    MNEMONIC_WORDLIST_ALLOWED_SIZES.includes(
      words.length
    ),
    HDNODE2.INVALID_HDNODE_MNEMONICS,
    "Invalid mnemonic size. Mnemonic must be 12, 15, 18, 21, or 24 words.",
    { words }
  );
  assertIsValidHdNodeDerivationPath("fromMnemonic", path);
  const joinedWords = words.join(" ").toLowerCase();
  const node = ethers8.HDNodeWallet.fromMnemonic(
    ethers8.Mnemonic.fromPhrase(joinedWords),
    path
  );
  return ethersNodeToOurHDNode(node);
}
function fromPublicKey2(publicKey, chainCode) {
  assert23(
    "fromPublicKey",
    publicKey.length === 65,
    HDNODE2.INVALID_HDNODE_PUBLIC_KEY,
    "Invalid public key. Length must be exactly 65 bytes.",
    { publicKey }
  );
  assertIsValidHdNodeChainCode("fromPublicKey", chainCode);
  const compressed = secp256k1.extendedPublicKeyToArray(publicKey, true);
  const key = Buffer.concat([
    X_PUB_PREFIX,
    chainCode,
    Buffer.from(compressed)
  ]);
  const checksum = sha256(sha256(key));
  const slicedChecksum = checksum.subarray(0, 4);
  const node = ethers8.HDNodeWallet.fromExtendedKey(
    ethers8.encodeBase58(Buffer.concat([key, slicedChecksum]))
  );
  return ethersNodeToOurHDNode(node);
}
function fromPrivateKey2(privateKey, chainCode) {
  assert23(
    "fromPrivateKey",
    privateKey.length === 32,
    HDNODE2.INVALID_HDNODE_PRIVATE_KEY,
    "Invalid private key. Length must be exactly 32 bytes.",
    { privateKey }
  );
  assertIsValidHdNodeChainCode("fromPrivateKey", chainCode);
  const key = Buffer.concat([
    X_PRIV_PREFIX,
    chainCode,
    Buffer.from([0]),
    privateKey
  ]);
  const checksum = sha256(sha256(key));
  const slicedChecksum = checksum.subarray(0, 4);
  const node = ethers8.HDNodeWallet.fromExtendedKey(
    ethers8.encodeBase58(Buffer.concat([key, slicedChecksum]))
  );
  return ethersNodeToOurHDNode(node);
}
function ethersNodeToOurHDNode(ethersNode) {
  const pub = Buffer.from(
    secp256k1.extendedPublicKeyToArray(
      Buffer.from(ethersNode.publicKey.slice(2), "hex"),
      false
    )
  );
  const cc = Buffer.from(ethersNode.chainCode.slice(2), "hex");
  const addr = addressUtils.fromPublicKey(pub);
  return {
    get publicKey() {
      return pub;
    },
    get privateKey() {
      if (ethersNode.privateKey !== void 0)
        return Buffer.from(ethersNode.privateKey.slice(2), "hex");
      return null;
    },
    get chainCode() {
      return cc;
    },
    get address() {
      return addr;
    },
    derive(index) {
      return ethersNodeToOurHDNode(ethersNode.deriveChild(index));
    },
    derivePath(path) {
      assertIsValidHdNodeDerivationPath("ethersNodeToOurHDNode", path);
      return ethersNodeToOurHDNode(ethersNode.derivePath(path));
    }
  };
}
var HDNode = {
  fromMnemonic,
  fromPublicKey: fromPublicKey2,
  fromPrivateKey: fromPrivateKey2
};

// src/keystore/keystore.ts
import { ethers as ethers9 } from "ethers";
import { assert as assert24, buildError as buildError6, KEYSTORE } from "@vechain/sdk-errors";
async function encrypt(privateKey, password) {
  const derivePublicKey2 = secp256k1.derivePublicKey(privateKey);
  const deriveAddress2 = addressUtils.fromPublicKey(derivePublicKey2);
  const keystoreAccount = {
    address: deriveAddress2,
    privateKey: Hex.of0x(privateKey)
  };
  const encryptOptions = {
    scrypt: {
      N: SCRYPT_PARAMS.N,
      r: SCRYPT_PARAMS.r,
      p: SCRYPT_PARAMS.p
    }
  };
  const keystoreJsonString = await ethers9.encryptKeystoreJson(
    keystoreAccount,
    password,
    encryptOptions
  );
  return JSON.parse(keystoreJsonString);
}
async function decrypt(keystore2, password) {
  assert24(
    "keystore.decrypt",
    isValid(keystore2),
    KEYSTORE.INVALID_KEYSTORE,
    "Invalid keystore. Ensure the keystore is properly formatted and contains the necessary data.",
    {
      keystore: keystore2
    }
  );
  try {
    return await ethers9.decryptKeystoreJson(
      JSON.stringify(keystore2),
      password
    );
  } catch (e) {
    throw buildError6(
      "keystore.decrypt",
      KEYSTORE.INVALID_PASSWORD,
      "Decryption failed: Invalid Password for the given keystore.",
      {
        keystore: keystore2,
        password
      },
      e
    );
  }
}
function isValid(keystore2) {
  return ethers9.isKeystoreJson(JSON.stringify(keystore2));
}
var keystore = { encrypt, decrypt, isValid };

// src/mnemonic/mnemonic.ts
import { ethers as ethers10 } from "ethers";
import { randomBytes as randomBytes3 } from "crypto";
import { assert as assert25, HDNODE as HDNODE3 } from "@vechain/sdk-errors";
function generate(wordlistSize, randomGenerator) {
  assert25(
    "generate",
    wordlistSize === void 0 || MNEMONIC_WORDLIST_ALLOWED_SIZES.includes(wordlistSize),
    HDNODE3.INVALID_HDNODE_MNEMONICS,
    "Invalid wordlist size given as input. Allowed sizes are 12, 15, 18, 21, 24 words.",
    { wordlistSize }
  );
  randomGenerator = randomGenerator ?? // Default random generator
  ((numberOfBytes) => randomBytes3(numberOfBytes));
  const wordlistSizeToUse = wordlistSize ?? 12;
  return ethers10.Mnemonic.fromEntropy(
    randomGenerator(
      wordlistSizeToUse / 3 * 4
    )
  ).phrase.split(" ");
}
function validate(words) {
  return ethers10.Mnemonic.isValidMnemonic(words.join(" "));
}
function derivePrivateKey(words, derivationPathFromCurrentNode = "0") {
  return HDNode.fromMnemonic(words).derivePath(derivationPathFromCurrentNode).privateKey;
}
function deriveAddress(words, derivationPathFromCurrentNode = "0") {
  return HDNode.fromMnemonic(words).derivePath(derivationPathFromCurrentNode).address;
}
var mnemonic = {
  generate,
  validate,
  derivePrivateKey,
  deriveAddress
};

// src/transaction/transaction.ts
import { ADDRESS as ADDRESS3, assert as assert26, SECP256K1 as SECP256K14, TRANSACTION as TRANSACTION2 } from "@vechain/sdk-errors";
var Transaction = class _Transaction {
  /**
   * Transaction body. It represents the body of the transaction.
   *
   * @note It is better to take it as a read-only property in order to avoid any external modification.
   */
  body;
  /**
   * Transaction signature. It represents the signature of the transaction.
   *
   * @note It is better to take it as a read-only property in order to avoid any external modification.
   */
  signature;
  /**
   * Constructor with parameters.
   * This constructor creates a transaction immutable object.
   *
   * @throws{TransactionBodyError, InvalidSecp256k1SignatureError}
   * @param body - Transaction body
   * @param signature - Optional signature for the transaction
   */
  constructor(body, signature) {
    assert26(
      "Transaction constructor",
      _Transaction.isValidBody(body),
      TRANSACTION2.INVALID_TRANSACTION_BODY,
      "Invalid transaction body. Ensure all required fields are correctly formatted and present.",
      { body }
    );
    this.body = body;
    if (signature !== void 0) {
      assert26(
        "Transaction constructor",
        this._isSignatureValid(signature),
        SECP256K14.INVALID_SECP256k1_SIGNATURE,
        "Invalid transaction signature. Ensure it is correctly formatted.",
        { signature }
      );
      this.signature = signature;
    }
  }
  // ********** PUBLIC GET ONLY FUNCTIONS **********
  /**
   * Calculate intrinsic gas required for this transaction
   *
   * @returns Intrinsic gas required for this transaction
   */
  get intrinsicGas() {
    return TransactionUtils.intrinsicGas(this.body.clauses);
  }
  /**
   * Determines whether the transaction is delegated.
   *
   * @returns If transaction is delegated or not
   */
  get isDelegated() {
    return this._isDelegated(this.body);
  }
  /**
   * Get transaction delegator address from signature.
   *
   * @throws{TransactionDelegationError, TransactionNotSignedError}
   * @returns Transaction delegator address
   */
  get delegator() {
    assert26(
      "delegator",
      this.isDelegated,
      TRANSACTION2.INVALID_DELEGATION,
      "Transaction is not delegated. Delegator information is unavailable."
    );
    assertCantGetFieldOnUnsignedTransaction("delegator", this, "delegator");
    const signatureSliced = this.signature.subarray(
      65,
      this.signature?.length
    );
    const delegatorPublicKey = secp256k1.recover(
      this.getSignatureHash(this.origin),
      signatureSliced
    );
    return addressUtils.fromPublicKey(delegatorPublicKey);
  }
  /**
   * Determines whether the transaction is signed or not.
   *
   * @returns If transaction is signed or not
   */
  get isSigned() {
    return this.signature !== void 0;
  }
  /**
   * Computes the signature hash for the transaction. The output is based on
   * the presence of the 'delegateFor' parameter.
   *
   * @param delegateFor - Optional address of the delegator.
   * @returns The computed hash.
   *
   * Mainly:
   *  - No 'delegateFor': return txHash
   * - 'delegateFor' return txHash +  hash('delegateFor' address)
   *
   * @remarks
   * delegateFor is used to sign a transaction on behalf of another account.
   * In fact when the delegator sign the transaction, delegator will add the address
   * of who send the transaction to sign (in this case the 'delegateFor' address parameter)
   *
   * @example
   * A is transaction origin
   * B is the delegator
   * TX is the transaction
   *
   * A sends a TX (signed by A) to B to who add his signature to TX using delegateFor parameter (that is A address)
   * on signing hash of TX computation.
   *
   * Mathematically:
   *
   * ```
   * final_signature = concat_buffer(
   *      sign(TX.signingHash(), A.privateKey),
   *      sign(TX.signingHash(A.address), B.privateKey)
   * )
   * ```
   *
   * Where:
   *
   * ```
   * TX.signatureHash() = blake2b256(TX.encoded)
   * TX.signingHash(A.address) = blake2b256(
   *      concat(
   *              blake2b256(TX.encoded),
   *              A.address
   *             )
   * )
   * ```
   *
   * @throws{InvalidAddressError}
   * @param delegateFor - Address of the delegator
   * @returns Signing hash of the transaction
   */
  getSignatureHash(delegateFor) {
    assert26(
      "getSignatureHash",
      delegateFor === void 0 || addressUtils.isAddress(delegateFor),
      ADDRESS3.INVALID_ADDRESS,
      "Invalid address given as input as delegateFor parameter. Ensure it is a valid address.",
      { delegateFor }
    );
    const transactionHash = blake2b256(this._encode(false));
    if (delegateFor !== void 0) {
      return blake2b256(
        Buffer.concat([
          transactionHash,
          Buffer.from(delegateFor.slice(2), "hex")
        ])
      );
    }
    return transactionHash;
  }
  /**
   * Encode a transaction
   *
   * @returns The transaction encoded
   */
  get encoded() {
    return this._encode(this.isSigned);
  }
  /**
   * Get transaction origin address from signature.
   *
   * @throws{TransactionNotSignedError}
   * @returns Transaction origin
   */
  get origin() {
    assertCantGetFieldOnUnsignedTransaction("origin", this, "origin");
    const signatureSliced = this.signature.subarray(0, 65);
    const originPublicKey = secp256k1.recover(
      this.getSignatureHash(),
      signatureSliced
    );
    return addressUtils.fromPublicKey(originPublicKey);
  }
  /**
   * Get transaction ID from signature.
   *
   * @throws{TransactionNotSignedError}
   * @returns Transaction ID
   */
  get id() {
    assertCantGetFieldOnUnsignedTransaction("id", this, "id");
    return blake2b256(
      Buffer.concat([
        this.getSignatureHash(),
        Buffer.from(this.origin.slice(2), "hex")
      ]),
      "hex"
    );
  }
  // ********** INTERNAL PRIVATE FUNCTIONS **********
  /**
   * Internal function to check if transaction is delegated or not.
   * This function is used to check directly the transaction body.
   * @private
   *
   * @param body Transaction body to check
   * @returns Weather the transaction is delegated or not
   */
  _isDelegated(body) {
    const reserved = body.reserved ?? {};
    const features = reserved.features ?? 0;
    return (features & 1) === 1;
  }
  /**
   * Internal function to check if signature is valid or not.
   * This function is used to check directly the signature.
   * @private
   *
   * @param signature Signature to check
   * @returns Weather the signature is valid or not
   */
  _isSignatureValid(signature) {
    const expectedSignatureLength = this._isDelegated(this.body) ? SIGNATURE_LENGTH * 2 : SIGNATURE_LENGTH;
    return signature.length === expectedSignatureLength;
  }
  /**
   * Encodes the reserved field to ensure it exists in every encoding.
   *
   * Due to the fact that reserved field is optional in TransactionBody,
   * BUT mandatory in RLPProfiler, we need to have it in every encoding.
   * Fot this reason this function is needed.
   * @private
   *
   * @returns Encoding of reserved field
   */
  _encodeReservedField() {
    const reserved = this.body.reserved ?? {};
    const featuresKind = TRANSACTION_FEATURES_KIND.kind;
    const featuresList = [
      featuresKind.data(reserved.features ?? 0, TRANSACTION_FEATURES_KIND.name).encode(),
      ...reserved.unused ?? []
    ];
    while (featuresList.length > 0) {
      if (featuresList[featuresList.length - 1].length === 0) {
        featuresList.pop();
      } else {
        break;
      }
    }
    return featuresList;
  }
  /**
   * Make the RLP encoding of a transaction body.
   * @private
   *
   * @param body Body to encode
   * @param isSigned If transaction is signed or not
   * @returns RLP encoding of transaction body
   */
  _lowLevelEncodeTransactionBodyWithRLP(body, isSigned) {
    if (isSigned) {
      return SIGNED_TRANSACTION_RLP.encodeObject({
        ...body,
        signature: this.signature
      });
    }
    return UNSIGNED_TRANSACTION_RLP.encodeObject(body);
  }
  /**
   * Private utility function to encode a transaction.
   * @private
   *
   * @param isSigned If transaction is signed or not (needed to determine if encoding with SIGNED_TRANSACTION_RLP or UNSIGNED_TRANSACTION_RLP)
   * @returns Encoding of transaction
   */
  _encode(isSigned) {
    return this._lowLevelEncodeTransactionBodyWithRLP(
      {
        // Existing body (clauses, gasPrice, gasLimit, nonce, chainTag, blockRef, expiration, ... AND OPTIONALLY reserved field)
        ...this.body,
        /*
         * @note: this.body.clauses is already an array.
         * But TypeScript doesn't know that and for this reason we need to cast it.
         * Otherwise encodeObject will throw an error.
         */
        clauses: this.body.clauses,
        // New reserved field
        reserved: this._encodeReservedField()
      },
      isSigned
    );
  }
  /**
   * utility function to check transaction body validity.
   *
   * @param body Transaction body to check
   */
  static isValidBody(body) {
    return (
      // Chain tag
      body.chainTag !== void 0 && body.chainTag >= 0 && body.chainTag <= 255 && // Block reference
      body.blockRef !== void 0 && dataUtils.isHexString(body.blockRef) && Buffer.from(body.blockRef.slice(2), "hex").length === BLOCK_REF_LENGTH && // Expiration
      body.expiration !== void 0 && // Clauses
      body.clauses !== void 0 && // Gas price coef
      body.gasPriceCoef !== void 0 && // Gas
      body.gas !== void 0 && // Depends on
      body.dependsOn !== void 0 && // Nonce
      body.nonce !== void 0
    );
  }
};

// src/transaction/handlers/sign.ts
import { assert as assert27, TRANSACTION as TRANSACTION3 } from "@vechain/sdk-errors";
function sign2(transactionBody, signerPrivateKey) {
  assertIsValidTransactionSigningPrivateKey(
    "sign",
    signerPrivateKey,
    secp256k1.isValidPrivateKey
  );
  const transactionToSign = new Transaction(transactionBody);
  assert27(
    "sign",
    !transactionToSign.isDelegated,
    TRANSACTION3.INVALID_DELEGATION,
    "Transaction is delegated. Use signWithDelegator method instead.",
    { transactionBody }
  );
  const signature = secp256k1.sign(
    transactionToSign.getSignatureHash(),
    signerPrivateKey
  );
  return new Transaction(transactionBody, signature);
}
function signWithDelegator(transactionBody, signerPrivateKey, delegatorPrivateKey) {
  assertIsValidTransactionSigningPrivateKey(
    "signWithDelegator",
    signerPrivateKey,
    secp256k1.isValidPrivateKey,
    "signer"
  );
  assertIsValidTransactionSigningPrivateKey(
    "signWithDelgator",
    delegatorPrivateKey,
    secp256k1.isValidPrivateKey,
    "delegator"
  );
  const transactionToSign = new Transaction(transactionBody);
  assert27(
    "signWithDelegator",
    transactionToSign.isDelegated,
    TRANSACTION3.INVALID_DELEGATION,
    "Transaction is not delegated. Use sign method instead.",
    { transactionToSign }
  );
  const transactionHash = transactionToSign.getSignatureHash();
  const delegatedHash = transactionToSign.getSignatureHash(
    addressUtils.fromPublicKey(secp256k1.derivePublicKey(signerPrivateKey))
  );
  const signature = Buffer.concat([
    secp256k1.sign(transactionHash, signerPrivateKey),
    secp256k1.sign(delegatedHash, delegatorPrivateKey)
  ]);
  return new Transaction(transactionBody, signature);
}

// src/transaction/handlers/decode.ts
import { assert as assert28, TRANSACTION as TRANSACTION4 } from "@vechain/sdk-errors";
function decode3(rawTransaction, isSigned) {
  const decoder = isSigned ? SIGNED_TRANSACTION_RLP : UNSIGNED_TRANSACTION_RLP;
  const decodedRLPBody = decoder.decodeObject(
    rawTransaction
  );
  const bodyWithoutReservedField = {
    blockRef: decodedRLPBody.blockRef,
    chainTag: decodedRLPBody.chainTag,
    clauses: decodedRLPBody.clauses,
    dependsOn: decodedRLPBody.dependsOn,
    expiration: decodedRLPBody.expiration,
    gas: decodedRLPBody.gas,
    gasPriceCoef: decodedRLPBody.gasPriceCoef,
    nonce: decodedRLPBody.nonce
  };
  const correctTransactionBody = decodedRLPBody.reserved.length > 0 ? {
    ...bodyWithoutReservedField,
    reserved: _decodeReservedField(
      decodedRLPBody.reserved
    )
  } : bodyWithoutReservedField;
  return decodedRLPBody.signature !== void 0 ? new Transaction(
    correctTransactionBody,
    decodedRLPBody.signature
  ) : new Transaction(correctTransactionBody);
}
function _decodeReservedField(reserved) {
  assert28(
    "_decodeReservedField",
    reserved[reserved.length - 1].length !== 0,
    TRANSACTION4.INVALID_TRANSACTION_BODY,
    "Invalid reserved field. Fields in the reserved buffer must be properly trimmed.",
    { reserved }
  );
  const featuresField = TRANSACTION_FEATURES_KIND.kind.buffer(reserved[0], TRANSACTION_FEATURES_KIND.name).decode();
  return reserved.length > 1 ? {
    features: featuresField,
    unused: reserved.slice(1)
  } : { features: featuresField };
}

// src/transaction/transaction-handler.ts
var TransactionHandler = {
  // Sign transaction
  sign: sign2,
  signWithDelegator,
  // Decode transaction
  decode: decode3
};

// src/utils/const/network.ts
var VECHAIN_MAINNET_CHAIN_TAG = 74;
var VECHAIN_TESTNET_CHAIN_TAG = 39;
var VECHAIN_SOLO_CHAIN_TAG = 246;
var ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
var VTHO_ADDRESS = "0x0000000000000000000000000000456e65726779";
var PARAMS_ADDRESS = "0x0000000000000000000000000000506172616d73";
var mainnetGenesisBlock = {
  number: 0,
  id: "0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a",
  size: 170,
  parentID: "0xffffffff53616c757465202620526573706563742c20457468657265756d2100",
  timestamp: 1530316800,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var testnetGenesisBlock = {
  number: 0,
  id: "0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127",
  size: 170,
  parentID: "0xffffffff00000000000000000000000000000000000000000000000000000000",
  timestamp: 1530014400,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var soloGenesisBlock = {
  number: 0,
  id: "0x00000000c05a20fbca2bf6ae3affba6af4a74b800b585bf7a4988aba7aea69f6",
  size: 170,
  parentID: "0xffffffff00000000000000000000000000000000000000000000000000000000",
  timestamp: 15264e5,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x93de0ffb1f33bc0af053abc2a87c4af44594f5dcb1cb879dd823686a15d68550",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var MAINNET_NETWORK = {
  genesisBlock: mainnetGenesisBlock,
  chainTag: VECHAIN_MAINNET_CHAIN_TAG
};
var TESTNET_NETWORK = {
  genesisBlock: testnetGenesisBlock,
  chainTag: VECHAIN_TESTNET_CHAIN_TAG
};
var SOLO_NETWORK = {
  genesisBlock: soloGenesisBlock,
  chainTag: VECHAIN_SOLO_CHAIN_TAG
};
var networkInfo = {
  mainnet: MAINNET_NETWORK,
  testnet: TESTNET_NETWORK,
  solo: SOLO_NETWORK
};
export {
  BLOCK_REF_LENGTH,
  BLOOM_REGEX_LOWERCASE,
  BLOOM_REGEX_UPPERCASE,
  DECIMAL_INTEGER_REGEX,
  ERC721_ABI,
  HDNode,
  HEX_ADDRESS_REGEX,
  HEX_REGEX,
  HEX_REGEX_OPTIONAL_PREFIX,
  Hex,
  MAINNET_NETWORK,
  MNEMONIC_WORDLIST_ALLOWED_SIZES,
  NUMERIC_REGEX,
  PARAMS_ABI,
  PARAMS_ADDRESS,
  PRIVATE_KEY_MAX_VALUE,
  RLP2 as RLP,
  RLPBase,
  RLPProfiles,
  SCRYPT_PARAMS,
  SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK,
  TESTNET_NETWORK,
  THOR_ID_LENGTH,
  TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND,
  Transaction,
  TransactionHandler,
  TransactionUtils,
  UNSIGNED_TRANSACTION_RLP,
  VET_DERIVATION_PATH,
  VIP180_ABI,
  VTHO_ADDRESS,
  X_PRIV_PREFIX,
  X_PUB_PREFIX,
  ZERO_ADDRESS,
  ZERO_BUFFER,
  abi,
  addressUtils,
  assertCantGetFieldOnUnsignedTransaction,
  assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData,
  assertIsAddress,
  assertIsArray,
  assertIsRevisionForAccount,
  assertIsRevisionForBlock,
  assertIsSignedTransaction,
  assertIsValidBuffer,
  assertIsValidHdNodeChainCode,
  assertIsValidHdNodeDerivationPath,
  assertIsValidPrivateKey,
  assertIsValidReturnType,
  assertIsValidSecp256k1MessageHash,
  assertIsValidTransactionSigningPrivateKey,
  assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData,
  assertValidNumericKindBuffer,
  assertValidTransactionHead,
  assertValidTransactionID,
  blake2b256,
  bloom,
  bloomUtils,
  certificate,
  clauseBuilder,
  coder,
  core_exports as core,
  dataUtils,
  decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex,
  encodeBigIntToBuffer,
  encodeCompactFixedHexBlob,
  fragment,
  isDerivationPathValid,
  keccak256,
  keystore,
  mnemonic,
  networkInfo,
  ofBuffer,
  revisionUtils,
  secp256k1,
  sha256,
  unitsUtils,
  validateNumericKindData,
  ethers11 as vechain_sdk_core_ethers
};

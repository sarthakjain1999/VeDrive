import { ethers, InterfaceAbi as InterfaceAbi$1, BytesLike as BytesLike$1 } from 'ethers';
export { ethers as vechain_sdk_core_ethers } from 'ethers';
import { Buffer as Buffer$1 } from 'buffer';
import * as _ethereumjs_rlp from '@ethereumjs/rlp';
import { Input, NestedUint8Array } from '@ethereumjs/rlp';

/**
 * Represents a wrapped Param Type for ethers.js types.
 */
type ParamType = ethers.ParamType;

/**
 * Represents a wrapped Function Fragment for ethers.js types.
 */
type FunctionFragment = ethers.FunctionFragment;

/**
 * Represents a wrapped Interface for ethers.js types.
 */
type Interface = ethers.Interface;

/**
 * Represents a wrapped InterfaceAbi for ethers.js types.
 */
type InterfaceAbi = ethers.InterfaceAbi;

/**
 * Represents a wrapped Result for ethers.js types.
 * It represents the decoded data from a transaction (after decoding).
 */
type Result = ethers.Result;

/**
 * Represents a wrapped Log description for ethers.js types.
 * It represents the decoded data from a log (after decoding).
 */
type Log = ethers.LogDescription;

/**
 * Represents a wrapped BytesLike for ethers.js types.
 */
type BytesLike = ethers.BytesLike;

/**
 * Represents a wrapped FormatType for ethers.js types.
 * It is used to represents the format of the signature of a function.
 */
type FormatType = ethers.FormatType;

/**
 * Represents a function call in the Event/Function ABI.
 *
 * @template ABIType - The ABI fragment type.
 */
declare class Function<ABIType> {
    /**
     * The main fragment handled by ethers.js.
     *
     */
    fragment: FunctionFragment;
    /**
     * The main interface handled by ethers.js.
     */
    iface: Interface;
    /**
     * Creates a new Function instance from an ABI fragment.
     *
     * @throws{InvalidAbiFunctionError}
     * @param source - ABI fragment to use.
     */
    constructor(source: ABIType);
    /**
     * Get the signature hash of the function.
     *
     * @returns The signature hash of the function.
     */
    signatureHash(): string;
    /**
     * Get the signature of the function.
     *
     * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
     * @returns The signature of the function.
     */
    signature(formatType: FormatType): string;
    /**
     * Decode data using the function's ABI.
     *
     * @throws{InvalidAbiDataToDecodeError} - If the data cannot be decoded.
     * @param data - Data to decode.
     * @returns Decoding results.
     */
    decodeInput(data: BytesLike): Result;
    /**
     * Decodes the output data from a transaction based on ABI (Application Binary Interface) specifications.
     * This method attempts to decode the given byte-like data into a readable format using the contract's interface.
     *
     * @param data - The `BytesLike` data to be decoded, typically representing the output of a contract function call.
     * @returns A `Result` object containing the decoded data.
     *
     * @throws{InvalidAbiDataToDecodeError} - If the data cannot be decoded.
     *
     * @example
     * ```typescript
     *   const decoded = contractInstance.decodeOutput(rawTransactionOutput);
     *   console.log('Decoded Output:', decoded);
     * ```
     */
    decodeOutput(data: BytesLike): Result;
    /**
     * Encode data using the function's ABI.
     *
     * @throws{InvalidAbiDataToEncodeError}
     * @param dataToEncode - Data to encode.
     * @returns Encoded data.
     */
    encodeInput<TValue>(dataToEncode?: TValue[]): string;
}
/**
 * Represents an event call in the Event/Function ABI.
 *
 * @template ABIType - The ABI fragment type.
 */
declare class Event<ABIType> {
    /**
     * The main fragment handled by ethers.js.
     */
    fragment: ethers.EventFragment;
    /**
     * The main interface handled by ethers.js.
     */
    iface: Interface;
    /**
     * Creates a new Event instance from an ABI fragment.
     *
     * @throws{InvalidAbiEventError}
     * @param source - ABI fragment to use.
     */
    constructor(source: ABIType);
    /**
     * Get the signature hash of the event.
     *
     * @returns The signature hash of the event.
     */
    signatureHash(): string;
    /**
     * Get the signature of the event.
     *
     * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
     * @returns The signature of the event.
     */
    signature(formatType: FormatType): string;
    /**
     * Decode event log data using the event's ABI.
     *
     * @throws{InvalidAbiDataToDecodeError}
     * @param data - Data to decode.
     * @returns Decoding results.
     */
    decodeEventLog(data: {
        data: string;
        topics: string[];
    }): Result;
    /**
     * Encode event log data using the event's ABI.
     *
     * @throws{InvalidAbiDataToEncodeError}
     * @param dataToEncode - Data to encode.
     * @returns Encoded data along with topics.
     */
    encodeEventLog<TValue>(dataToEncode: TValue[]): {
        data: string;
        topics: string[];
    };
    /**
     * Encode event log topics using the event's ABI.
     *
     * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.
     *                         Only the values of the indexed parameters are needed.
     *
     * @returns Encoded topics array.
     */
    encodeFilterTopics<TValue>(valuesToEncode: TValue[]): Array<string | undefined>;
}
/**
 * Object containing ABI representations.
 */
declare const fragment: {
    Function: typeof Function;
    Event: typeof Event;
};

/**
 * Encodes a parameter value.
 *
 * @note `ValueType` is used to explicitly specify the type of the value to encode.
 *
 * @throws{InvalidAbiDataToEncodeError}
 * @param type - Type of the parameter.
 * @param value - Value to encode.
 * @returns Encoded parameter as a hexadecimal string.
 */
declare function encode$2<ValueType>(type: string | ParamType, value: ValueType): string;
/**
 * Encodes the given values according to the specified ABI types.
 *
 * @param types - An array of ABI types or an array of ParamType objects representing the types of the values to encode.
 * @param values - An array of values to be encoded according to the specified ABI types.
 * @returns The ABI-encoded string representing the given values.
 * @throws Throws an error if encoding fails. The error message indicates that the data must be a valid ABI type with corresponding valid data.
 *
 * @template ValueType - The type of the values being encoded.
 *
 * @example
 * ```typescript
 * const abiTypes = ['uint256', 'address'];
 * const values = [123, '0x1234567890123456789012345678901234567890'];
 * const encodedParams = encodeParams(abiTypes, values);
 * console.log(encodedParams);
 * ```
 */
declare function encodeParams(types: string[] | ParamType[], values: string[]): string;
/**
 * Decodes a parameter value.
 *
 * @note `ReturnType` is used to explicitly specify the return type (the decoded value) of the function.
 *
 * @throws{InvalidAbiDataToDecodeError}
 * @param types - Types of parameters.
 * @param data - Data to decode.
 * @returns Decoded parameter value.
 */
declare function decode$2<ReturnType>(types: string | ParamType, data: BytesLike): ReturnType;
/**
 * Object containing ABI representations.
 */
declare const abi: {
    encode: typeof encode$2;
    encodeParams: typeof encodeParams;
    decode: typeof decode$2;
    Function: {
        new <ABIType>(source: ABIType): {
            fragment: ethers.FunctionFragment;
            iface: ethers.Interface;
            signatureHash(): string;
            signature(formatType: ethers.FormatType): string;
            decodeInput(data: ethers.BytesLike): ethers.Result;
            decodeOutput(data: ethers.BytesLike): ethers.Result;
            encodeInput<TValue>(dataToEncode?: TValue[] | undefined): string;
        };
    };
    Event: {
        new <ABIType_1>(source: ABIType_1): {
            fragment: ethers.EventFragment;
            iface: ethers.Interface;
            signatureHash(): string;
            signature(formatType: ethers.FormatType): string;
            decodeEventLog(data: {
                data: string;
                topics: string[];
            }): ethers.Result;
            encodeEventLog<TValue_1>(dataToEncode: TValue_1[]): {
                data: string;
                topics: string[];
            };
            encodeFilterTopics<TValue_2>(valuesToEncode: TValue_2[]): (string | undefined)[];
        };
    };
};

/**
 * Creates a new Interface instance from an ABI fragment.
 * @param abi - ABI in a compatible format
 * @returns The Interface instance.
 */
declare function createInterface(abi: InterfaceAbi$1): Interface;
/**
 * Encode function data that can be used to send a transaction.
 * @param interfaceABI ABI in a compatible format
 * @param functionName The name of the function defined in the ABI.
 * @param functionData The data to pass to the function.
 * @returns The encoded data that can be used to send a transaction.
 * @throws {InvalidAbiDataToDecodeError}
 */
declare function encodeFunctionInput(interfaceABI: InterfaceAbi$1, functionName: string, functionData?: unknown[]): string;
/**
 * Decode the function data of an encoded function
 * @param interfaceABI ABI in a compatible format
 * @param functionName The name of the function defined in the ABI.
 * @param encodedFunctionInput The encoded function data.
 * @returns an array of the decoded function data
 *
 * @throws {InvalidAbiDataToDecodeError}
 */
declare function decodeFunctionInput(interfaceABI: InterfaceAbi$1, functionName: string, encodedFunctionInput: BytesLike): Result;
/**
 * Decodes the output from a contract function using the specified ABI and function name.
 * It takes the encoded function output and attempts to decode it according to the ABI definition.
 *
 * @param {InterfaceAbi} interfaceABI - The ABI (Application Binary Interface) of the contract,
 *                                      which defines how data is structured in the blockchain.
 * @param {string} functionName - The name of the function in the contract to decode the output for.
 * @param encodedFunctionOutput - The encoded output data from the contract function.
 * @returns {Result} - The decoded output as a Result object, which provides a user-friendly way
 *                     to interact with the decoded data.
 *
 * @throws Will throw an error if decoding fails, typically due to incorrect encoding or mismatch
 *         with the ABI specifications. The error will provide details on the specific issue encountered.
 *
 * @example
 * // Example of decoding output for a function called "getValue":
 * const decodedOutput = decodeFunctionOutput(contractABI, 'getValue', encodedValue);
 *
 */
declare function decodeFunctionOutput(interfaceABI: InterfaceAbi$1, functionName: string, encodedFunctionOutput: BytesLike): Result;
/**
 * Encodes event log data based on the provided contract interface ABI, event name, and data to encode.
 * @param interfaceABI - The ABI (Application Binary Interface) of the contract.
 * @param eventName - The name of the event to be encoded.
 * @param dataToEncode - An array of data to be encoded in the event log.
 * @returns An object containing the encoded data and topics.
 * @throws {InvalidAbiEventError} Throws an error if encoding fails, including relevant details.
 */
declare function encodeEventLog(interfaceABI: InterfaceAbi$1, eventName: string, dataToEncode: unknown[]): {
    data: string;
    topics: string[];
};
/**
 * Decodes event log data based on the provided contract interface ABI, event name, and data/topics to decode.
 * @param interfaceABI - The ABI (Application Binary Interface) of the contract.
 * @param eventName - The name of the event to be decoded.
 * @param dataToDecode - An object containing the data and topics to be decoded.
 * @returns The decoded data of the event log.
 * @throws {InvalidAbiEventError} Throws an error if decoding fails, including relevant details.
 */
declare function decodeEventLog(interfaceABI: InterfaceAbi$1, eventName: string, dataToDecode: {
    data: string;
    topics: string[];
}): Result;
/**
 * Decodes an Ethereum log based on the ABI definition.
 *
 * This method takes raw `data` and `topics` from an Ethereum log and attempts
 * to decode them using the contract's ABI definition. If the decoding is successful,
 * it returns a `Log` object representing the decoded information. If the decoding fails,
 * it throws a custom error with detailed information.
 *
 * @param interfaceABI - The ABI (Application Binary Interface) of the contract.
 * @param {string} data - The hexadecimal string of the data field in the log.
 * @param {string[]} topics - An array of hexadecimal strings representing the topics of the log.
 * @returns {Log | null} - A `Log` object representing the decoded log or null if decoding fails.
 * @throws {InvalidAbiDataToDecodeError} - if decoding fails due to invalid data or topics format.
 */
declare function parseLog(interfaceABI: InterfaceAbi$1, data: string, topics: string[]): Log | null;
declare const coder: {
    createInterface: typeof createInterface;
    encodeFunctionInput: typeof encodeFunctionInput;
    decodeFunctionInput: typeof decodeFunctionInput;
    decodeFunctionOutput: typeof decodeFunctionOutput;
    encodeEventLog: typeof encodeEventLog;
    decodeEventLog: typeof decodeEventLog;
    parseLog: typeof parseLog;
};

/**
 * Derives a vechain thor address from a public key.
 *
 * @remarks
 * This function generates a vechain thor address by utilizing the ethers.js library's `computeAddress` function.
 * Note that the public key should be provided in an uncompressed form.
 *
 * @param publicKey - The uncompressed public key as a `Buffer`.
 * @returns The derived vechain thor address as a string.
 */
declare function fromPublicKey$1(publicKey: Buffer): string;
/**
 * Derives an Ethereum address from a given private key.
 *
 * This function uses the `secp256k1` cryptographic function to derive the public key
 * from the provided private key, and then converts this public
 * key into a vechain address.
 *
 * @param privateKey - The private key as a Buffer object for which the vechain address
 *                     will be derived. The private key must be a valid secp256k1 private key.
 *
 * @returns The vechain address as a string, derived from the given private key.
 *
 */
declare function fromPrivateKey$1(privateKey: Buffer): string;
/**
 * Verifies whether a string qualifies as a valid vechain thor address.
 *
 * @remarks
 * This function checks a provided string against a regular expression to determine whether it is formatted as a valid vechain thor address.`
 *
 * @param addressToVerify - The string to be checked for address-like formatting.
 * @returns A boolean indicating whether the string adheres to vechain thor address formatting.
 */
declare function isAddress(addressToVerify: string): boolean;
/**
 * Converts a vechain thor address to its checksummed version.
 *
 * @remarks
 * This function validates and then converts an address into its EIP-55 compliant checksum form using ethers.js’s `getAddress` function.
 * Throws an error if the input string is not a valid vechain thor address.
 *
 * @throws{InvalidAddressError}
 * @param address - The input vechain thor address string to be checksummed.
 * @returns The checksum address string, compliant with EIP-55.
 */
declare function toChecksummed(address: string): string;
declare const addressUtils: {
    fromPublicKey: typeof fromPublicKey$1;
    fromPrivateKey: typeof fromPrivateKey$1;
    isAddress: typeof isAddress;
    toChecksummed: typeof toChecksummed;
};

/**
 * Bloom filter implementation.
 *
 * A Bloom filter is a space-efficient probabilistic data structure
 * that is used to test whether an element is a member of a set.
 * False positive matches are possible, but false negatives are not.
 *
 * Reference: https://github.com/vechain/thor/blob/master/thor/bloom/bloom.go
 */

/**
 * This class represents a Bloom filter with its associated bit array and
 * a specified number (k) of hash functions.
 */
declare class Filter {
    readonly bits: Buffer$1;
    readonly k: number;
    /**
     * Constructs a new Filter instance.
     * @param bits - The bit array used in the Bloom filter.
     * @param k - The number of hash functions to be used.
     */
    constructor(bits: Buffer$1, k: number);
    /**
     * Checks if the given key might be contained in the set.
     * Note: false positives are possible, but false negatives are not.
     * @param key - The key to be checked.
     * @returns A boolean indicating whether the key might be contained in the set.
     */
    contains(key: Buffer$1): boolean;
}
/**
 * Generator class for creating and managing Bloom filters.
 *
 * This class aids in the creation and management of Bloom filters.
 * It allows keys to be added, internally hashes them, and provides
 * a method to generate a Bloom filter based on the added keys.
 */
declare class Generator {
    private readonly hashes;
    /**
     * Adds a key to the generator's internal map for later Bloom filter generation.
     * @param key - The key to be added.
     */
    add(key: Buffer$1): void;
    /**
     * Generates a variable-length Bloom filter based on the bits per key and count of keys.
     * The generator will be reset after generation.
     *
     * @param bitsPerKey - The number of bits per key.
     * @param k - The number of hash functions to be used (count of keys).
     * @returns A new Filter instance.
     */
    generate(bitsPerKey: number, k: number): Filter;
}
/**
 * Calculates the optimal number of hash functions (`k`) based on bits per key.
 *
 * Mathematically, `k` is approximated as `(bitsPerKey * ln(2))` which is simplified
 * to `(bitsPerKey * 0.69)` for computational efficiency.
 * It also ensures that `k` stays within a practical range [1, 30].
 *
 * @param bitsPerKey - The number of bits per key.
 * @returns The calculated optimal `k` value.
 */
declare function calculateK(bitsPerKey: number): number;
declare const bloom: {
    Generator: typeof Generator;
    Filter: typeof Filter;
    calculateK: typeof calculateK;
};

/**
 * In the VechainThor blockchain, a certificate is a data structure used for client-side self-signed certificates.
 * It plays a crucial role in providing a mechanism for secure identification and validation of data.
 *
 * Certificates are primarily used for purposes like attestation, validation, and verification of data authenticity.
 * They are used as proofs of authenticity and origin for data exchanged within the vechain ecosystem.
 */
interface Certificate {
    /**
     * The purpose field indicates the intended use or context of the certificate.
     * For example, it could be used for identification, verification, or attestation.
     */
    purpose: string;

    /**
     * The payload field holds the actual content of the certificate.
     * This content can be of various types, such as text, images, or other data.
     */
    payload: {
        type: string;
        content: string;
    };

    /**
     * The domain field represents the specific context or domain for which the certificate is valid.
     * It helps ensure that the certificate is only applicable within the intended context.
     */
    domain: string;

    /**
     * The timestamp field records the time at which the certificate was created or issued.
     * This provides a temporal reference for the certificate's validity.
     */
    timestamp: number;

    /**
     * The signer field indicates the address of the entity that signs the certificate.
     * It is the public key address of the entity that issues the certificate.
     */
    signer: string;

    /**
     * The signature field contains the cryptographic signature generated by the issuer's private key.
     * This signature ensures the integrity and authenticity of the certificate's content.
     */
    signature?: string;
}

/**
 * Deterministically encodes a certificate into a JSON string.
 * @param cert - The certificate object to be encoded.
 * @returns A JSON string representation of the certificate.
 */
declare function encode$1(cert: Certificate): string;
/**
 * Verifies the validity of a certificate.
 *
 * @throws {CertificateNotSignedError, CertificateInvalidSignerError, CertificateInvalidSignatureFormatError}
 * @param cert - The certificate object with a digital signature.
 */
declare function verify(cert: Certificate): void;
/**
 * Exposes the certificate encoding and verification functions.
 */
declare const certificate: {
    encode: typeof encode$1;
    verify: typeof verify;
};

/**
 * `ScalarKind` Abstract Class - A base for scalar kinds providing contract for data and buffer manipulations.
 */
declare abstract class ScalarKind {
    /**
     * Abstract method to handle data encoding.
     * @param data - The data to encode.
     * @param context - Contextual information for error messaging.
     * @returns An object providing a mechanism to encode the data into a Buffer.
     */
    abstract data(data: RLPInput | RLPValidObject, context: string): DataOutput;
    /**
     * Abstract method to handle buffer decoding.
     * @param buffer - The buffer to decode.
     * @param context - Contextual information for error messaging.
     * @returns An object providing a mechanism to decode the buffer back into data.
     */
    abstract buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a scalar kind with Buffer functionality.
 * This class extends the {@link ScalarKind} class.
 */
declare class BufferKind extends ScalarKind {
    /**
     * Encodes the input data into buffer format.
     *
     * @throws{InvalidRLPError}
     * @param data - The data to encode, expected to be of buffer type.
     * @param context - Descriptive context for error messages
     * @returns DataOutput object with an encode function.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer.
     *
     * @throws{InvalidRLPError}
     * @param buffer - The buffer to decode, expected to be of buffer type.
     * @param context - Descriptive context for error messages, usually representing the caller's identity.
     * @returns BufferOutput object with a decode function.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a scalar kind with numeric functionality.
 * This class extends the {@link ScalarKind} class.
 */
declare class NumericKind extends ScalarKind {
    readonly maxBytes?: number | undefined;
    /**
     * Constructs a new instance of NumericKind.
     *
     * @param maxBytes - Optional parameter that specifies the maximum number of bytes that numeric data can occupy when encoded.
     */
    constructor(maxBytes?: number | undefined);
    /**
     * Encodes the input data into numeric format and ensures it doesn't exceed the maximum bytes, if specified.
     *
     * @param data - The data to encode, expected to be numeric.
     * @param context - Descriptive context for error messages
     * @returns DataOutput object with an encode function.
     * @throws Will throw an error if data validation fails or encoding issues occur.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a number or hexadecimal string, ensuring it meets numeric data constraints.
     *
     * @param buffer - The buffer to decode, containing numeric data.
     * @param context - Descriptive context for error messages.
     * @returns BufferOutput object with a decode function.
     * @throws Will throw an error if buffer validation fails.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a scalar kind with hex blob functionality.
 * This class extends the {@link ScalarKind} class.
 *
 * @remarks
 * A hex blob is a hex string that is prefixed with '0x' and has even length.
 */
declare class HexBlobKind extends ScalarKind {
    /**
     * Encodes the input data into a Buffer.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string.
     *
     * @param buffer - The buffer to decode.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a hex blob kind with fixed bytes size functionality.
 * This class extends the {@link HexBlobKind} class.
 */
declare class FixedHexBlobKind extends HexBlobKind {
    readonly bytes: number;
    /**
     * Creates a new instance of the {@link FixedHexBlobKind} class.
     * @param bytes - The number of bytes the blob must have.
     */
    constructor(bytes: number);
    /**
     * Encodes the input data into a Buffer with validation against fixed size.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string with validation against fixed size.
     *
     * @param buffer - The buffer to decode.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a fixed hex blob kind with optional data functionality.
 * This class extends the {@link FixedHexBlobKind} class.
 */
declare class OptionalFixedHexBlobKind extends FixedHexBlobKind {
    /**
     * Encodes the input data (which can be null or undefined) into a Buffer.
     *
     * @param data - The data to encode, can be null or undefined.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string or null if the buffer is empty.
     *
     * @param buffer - The buffer to decode, can be empty.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string or null.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a fixed hex blob kind with zero trimming and padding functionality.
 * This class extends the {@link FixedHexBlobKind} class.
 */
declare class CompactFixedHexBlobKind extends FixedHexBlobKind {
    /**
     * Encodes the input data into a Buffer, trimming leading zeros.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a number or hexadecimal string, ensuring it meets the fixed size by padding with zeros.
     *
     * @param buffer - The buffer to decode, containing numeric data.
     * @param context - Descriptive context for error messages, usually representing the caller's identity.
     * @returns BufferOutput object with a decode function.
     * @throws Will throw an error if buffer validation fails.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * RLP profile classes.
 */
declare const RLPProfiles: {
    ScalarKind: typeof ScalarKind;
    BufferKind: typeof BufferKind;
    NumericKind: typeof NumericKind;
    HexBlobKind: typeof HexBlobKind;
    FixedHexBlobKind: typeof FixedHexBlobKind;
    OptionalFixedHexBlobKind: typeof OptionalFixedHexBlobKind;
    CompactFixedHexBlobKind: typeof CompactFixedHexBlobKind;
};

/**
 * Represents a valid input for the RLP (Recursive Length Prefix) encoding.
 * The RLP encoding is used to encode arbitrary binary data (nested arrays of bytes).
 *
 * @typeParam Input - Can be a Buffer, Array of Inputs, Buffer array, or nested array of Inputs.
 * @see {@link https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/rlp/src/index.ts}
 */
type RLPInput = Input;

/**
 * Represents an output from RLP decoding.
 * This type can either be a single Uint8Array (byte array) or a nested structure
 * of Uint8Array instances.
 *
 * @typeParam Uint8Array - A typed array of 8-bit unsigned integers.
 * @typeParam NestedUint8Array - A possibly nested array of Uint8Arrays.
 */
type RLPOutput = Uint8Array | NestedUint8Array;

/**
 * Represents a complex RLP object.
 * This type allows for recursive nesting of RLPInput or further RLPComplexObjects,
 * allowing the definition of complex structures.
 *
 * @typeParam RLPInput - A valid RLP input type.
 * @typeParam RLPComplexObject - Recursive type to enable nesting of complex objects.
 */
interface RLPComplexObject {
    [key: string]: RLPInput | RLPComplexObject | RLPComplexObject[];
}

/**
 * Represents a valid RLP object.
 * It is a dictionary-like object where keys are strings and values can be
 * a valid RLP input type or a complex RLP object (which can be further nested).
 *
 * @typeParam RLPValueType - A type that represents all valid RLP values.
 */
type RLPValidObject = Record<string, RLPValueType>;

/**
 * Represents all valid RLP value types.
 * This type union is used to simplify the definition of valid value types within
 * RLP object structures, supporting single inputs, complex objects, and arrays
 * of complex objects.
 *
 * @typeParam RLPInput - A valid RLP input type.
 * @typeParam RLPComplexObject - A valid complex RLP object.
 */
type RLPValueType = RLPInput | RLPComplexObject | RLPComplexObject[];

/* ------- RLP Profile Types ------- */
/**
 * `RLPProfile` Interface - Describes the profile of the RLP encoding.
 */
interface RLPProfile {
    name: string;
    kind: ScalarKind | ArrayKind | StructKind;
}

/**
 * `ArrayKind` Interface - Describes an array-kind in the RLP encoding profile.
 */
interface ArrayKind {
    item: RLPProfile['kind'];
}

/**
 * `StructKind` Type - Describes a structured-kind in the RLP encoding profile using an array of `RLPProfile`.
 */
type StructKind = RLPProfile[];

/**
 * `DataOutput` Interface - Provides an encoding mechanism to convert data into a Buffer.
 */
interface DataOutput {
    encode: () => Buffer;
}

/**
 * `BufferOutput` Interface - Provides a decoding mechanism to convert a Buffer back into data.
 */
interface BufferOutput {
    decode: () => RLPInput;
}

/**
 * Encodes data using the Ethereumjs RLP library.
 * @param data - The data to be encoded.
 * @returns The encoded data as a Buffer.
 */
declare function encode(data: RLPInput): Buffer;
/**
 * Decodes RLP-encoded data using the Ethereumjs RLP library.
 * @param encodedData - The RLP-encoded data as a Buffer.
 * @returns The decoded data or null if decoding fails.
 */
declare function decode$1(encodedData: Buffer): RLPOutput;
/**
 * Class handling the profiling of RLP encoded/decoded objects.
 * Provides methods to encode and decode objects based on a provided RLP profile.
 */
declare class Profiler {
    readonly profile: RLPProfile;
    /**
     * Creates a new Profiler instance.
     * @param profile - RLP profile for encoding/decoding structures.
     */
    constructor(profile: RLPProfile);
    /**
     * Encodes an object following the provided RLP profile.
     * @param data - Object to be encoded.
     * @returns - Encoded data as a Buffer.
     */
    encodeObject(data: RLPValidObject): Buffer;
    /**
     * Decodes an object following the provided RLP profile.
     * @param encodedData - Data to be decoded.
     * @returns - Decoded data as RLPValueType.
     */
    decodeObject(encodedData: Buffer): RLPValueType;
}
declare const RLPBase: {
    encode: typeof encode;
    decode: typeof decode$1;
    Profiler: typeof Profiler;
};

/**
 * Validates and converts the input data to a BigInt.
 *
 * @throws{InvalidRLPError}
 * @param data - Either a number or a string representing a non-negative integer.
 * @param context - A string representing the context in which this function is used,
 *                 to create meaningful error messages.
 * @returns The input data converted to a BigInt.
 */
declare const validateNumericKindData: (data: RLPInput, context: string) => bigint;
/**
 * Validates a buffer to ensure it adheres to constraints and does not contain
 * leading zero bytes which are not canonical representation in integers.
 *
 * @throws{InvalidRLPError}
 * @param buf - The buffer to validate.
 * @param context - A string providing context for error messages.
 * @param maxBytes - [Optional] An integer representing the maximum allowed length
 *                   of the buffer. If provided, an error will be thrown if buf is longer.
 *
 * @private
 */
declare const assertValidNumericKindBuffer: (buf: Buffer, context: string, maxBytes?: number) => void;
/**
 * Encode a BigInt instance into a Buffer, ensuring it adheres to specific constraints.
 *
 * @throws{InvalidRLPError}
 * @param bi - BigInt instance to encode.
 * @param maxBytes - Maximum byte length allowed for the encoding. If undefined, no byte size limit is imposed.
 * @param context - Contextual information for error messages.
 * @returns A Buffer instance containing the encoded data.
 */
declare const encodeBigIntToBuffer: (bi: bigint, maxBytes: number | undefined, context: string) => Buffer;
/**
 * Decode a Buffer into a number or hexadecimal string.
 * @param buffer - Buffer instance to decode.
 * @returns A number if the decoded BigInt is a safe integer, otherwise returns a hexadecimal string.
 */
declare const decodeBufferToNumberOrHex: (buffer: Buffer) => number | string;

/**
 * Validates if the input is a proper hex string for HexBlobKind.
 *
 * @throws{InvalidRLPError}
 * @param data - The input data to validate.
 * @param context - Additional context for error handling.
 */
declare const assertValidHexBlobKindData: (data: RLPInput, context: string) => void;
/**
 * Validates if the input buffer is valid for HexBlobKind.
 *
 * @throws{InvalidRLPError}
 * @param buffer - The buffer to validate.
 * @param context - Additional context for error handling.
 */
declare const assertValidHexBlobKindBuffer: (buffer: Buffer, context: string) => void;

/**
 * Asserts that the data is a hex string of the correct length.
 *
 * @throws{InvalidRLPError} Will throw an error with a message containing the context if the data length is not equal to the specified bytes.
 * @param data - The data to validate.
 * @param context - Descriptive context for error messages.
 * @param bytes - The expected number of bytes that the data can contain.
 */
declare const assertFixedHexBlobKindData: (data: string, context: string, bytes: number) => void;
/**
 * Asserts that the buffer is of a specific length.
 *
 * @throws{InvalidRLPError} - Will throw an error with a message containing the context if the buffer length is not equal to the specified bytes.
 * @param buffer - The buffer to validate.
 * @param context - Descriptive context for error messages.
 * @param bytes - The expected number of bytes that the buffer can contain.
 *
 */
declare const assertFixedHexBlobKindBuffer: (buffer: Buffer, context: string, bytes: number) => void;

/**
 * Asserts that the provided buffer is of a specific length and does not contain leading zeros.
 *
 * @throws{InvalidRLPError} - Will throw an error with a message containing the context if the buffer length is greater than the specified bytes OR if it has leading zero bytes.
 * @param buffer - The buffer to validate.
 * @param context - Descriptive context for error messages, usually representing the caller's identity.
 * @param bytes - The expected maximum number of bytes that the buffer can contain.
 */
declare const assertCompactFixedHexBlobBuffer: (buffer: Buffer, context: string, bytes: number) => void;
/**
 * Encodes a buffer by trimming leading zero bytes.
 * Finds the first non-zero byte and returns a new buffer starting from that byte. Returns an empty buffer if all bytes are zero.
 *
 * @param buffer - The buffer to be Compact.
 * @returns A Buffer instance Compact of leading zero bytes, or an empty Buffer if all bytes are zero.
 */
declare const encodeCompactFixedHexBlob: (buffer: Buffer) => Buffer;
/**
 * Decodes a buffer into a hexadecimal string, ensuring a specific total byte length by prepending zeros if necessary.
 * Calculates the number of missing bytes compared to the expected total and prepends the corresponding number of '0' characters to the hexadecimal string representation of the buffer.
 *
 * @param buffer - The buffer to decode.
 * @param bytes - The expected total number of bytes in the final hexadecimal string (including leading zeros).
 * @returns A hexadecimal string with the necessary leading '0' characters to ensure the specified total byte length.
 */
declare const decodeBufferToHexWithLeadingZeros: (buffer: Buffer, bytes: number) => string;

/**
 * The `RLP` object, encapsulating all functionalities related to Recursive Length Prefix (RLP) encoding.
 *
 * RLP contains the following classes and methods:
 * - `encode` - Encodes data using the Ethereumjs RLP library.
 * - `decode` - Decodes RLP-encoded data using the Ethereumjs RLP library.
 * - `Profiler` - Class handling the profiling of RLP encoded/decoded objects.
 * - `ScalarKind` - Abstract class for scalar types.
 * - `BufferKind` - Class managing buffers and ensuring type safety with encode/decode methods.
 * - `NumericKind` - Class managing numerical data ensuring it adheres to specific constraints.
 */
declare const RLP: {
    ScalarKind: typeof ScalarKind;
    BufferKind: typeof BufferKind;
    NumericKind: typeof NumericKind;
    HexBlobKind: typeof HexBlobKind;
    FixedHexBlobKind: typeof FixedHexBlobKind;
    OptionalFixedHexBlobKind: typeof OptionalFixedHexBlobKind;
    CompactFixedHexBlobKind: typeof CompactFixedHexBlobKind;
    encode: (data: _ethereumjs_rlp.Input) => Buffer;
    decode: (encodedData: Buffer) => RLPOutput;
    Profiler: {
        new (profile: RLPProfile): {
            readonly profile: RLPProfile;
            encodeObject(data: RLPValidObject): Buffer;
            decodeObject(encodedData: Buffer): RLPValueType;
        };
    };
};

/**
 * Simple type for transaction clause.
 */
interface TransactionClause {
    /**
     * Destination address where:
     * * transfer token to or
     * * invoke contract method on.
     *
     * @note Set null destination to deploy a contract.
     */
    to: string | null;

    /**
     * Amount of token to transfer to the destination
     */
    value: string | number;

    /**
     * Input data for contract method invocation or deployment
     */
    data: string;
}

/**
 * Type for transaction body.
 */
interface TransactionBody {
    /**
     * Last byte of genesis block ID
     */
    chainTag: number;

    /**
     * 8 bytes prefix of some block's ID
     */
    blockRef: string;

    /**
     * Constraint of time bucket
     */
    expiration: number;

    /**
     * Array of clauses
     */
    clauses: TransactionClause[];

    /**
     * Coefficient applied to base gas price [0,255]
     */
    gasPriceCoef: number;

    /**
     * Max gas provided for execution
     */
    gas: string | number;

    /**
     * ID of another tx that is depended
     */
    dependsOn: string | null;

    /**
     * Nonce value for various purposes.
     * Basic is to prevent replay attack by make transaction unique.
     * Every transaction with same chainTag, blockRef, ... must have different nonce.
     */
    nonce: string | number;

    /**
     * A reserved field intended for features use.
     *
     * In standard EVM transactions, this reserved field typically is not present.
     * However, it's been designed to cater to VIP-191, which deals with fee delegation.
     *
     * If the `features` within the `reserved` field is set as `1111...111`, it indicates that the transaction has been delegated.
     * The method to check if the transaction is delegated is:
     *
     * ```typescript
     * reserved.features & 1 === 1
     * ```
     *
     * @example
     *
     * 1.
     * ```typescript
     * feature = 111101;
     * isDelegated = (111101 & 111111) === 111101; // false (not delegated)
     * ```
     *
     * 2.
     * ```typescript
     * feature = 111111;
     * isDelegated = (111111 & 111111) === 111111; // true (delegated)
     * ```
     *
     * @remarks
     * For more information on the subject, refer to {@link https://github.com/vechain/VIPs/blob/master/vips/VIP-191.md | VIP-191}.
     */
    reserved?: {
        /**
         * Tx feature bits
         */
        features?: number;
        /**
         * Unused
         */
        unused?: Buffer[];
    };
}

/**
 * Represents an immutable transaction entity.
 *
 * @remarks
 * Properties should be treated as read-only to avoid unintended side effects.
 * Any modifications create a new transaction instance which should be handled by the TransactionHandler component.
 *
 * @see {@link TransactionHandler} for transaction manipulation details.
 */
declare class Transaction {
    /**
     * Transaction body. It represents the body of the transaction.
     *
     * @note It is better to take it as a read-only property in order to avoid any external modification.
     */
    readonly body: TransactionBody;
    /**
     * Transaction signature. It represents the signature of the transaction.
     *
     * @note It is better to take it as a read-only property in order to avoid any external modification.
     */
    readonly signature?: Buffer;
    /**
     * Constructor with parameters.
     * This constructor creates a transaction immutable object.
     *
     * @throws{TransactionBodyError, InvalidSecp256k1SignatureError}
     * @param body - Transaction body
     * @param signature - Optional signature for the transaction
     */
    constructor(body: TransactionBody, signature?: Buffer);
    /**
     * Calculate intrinsic gas required for this transaction
     *
     * @returns Intrinsic gas required for this transaction
     */
    get intrinsicGas(): number;
    /**
     * Determines whether the transaction is delegated.
     *
     * @returns If transaction is delegated or not
     */
    get isDelegated(): boolean;
    /**
     * Get transaction delegator address from signature.
     *
     * @throws{TransactionDelegationError, TransactionNotSignedError}
     * @returns Transaction delegator address
     */
    get delegator(): string;
    /**
     * Determines whether the transaction is signed or not.
     *
     * @returns If transaction is signed or not
     */
    get isSigned(): boolean;
    /**
     * Computes the signature hash for the transaction. The output is based on
     * the presence of the 'delegateFor' parameter.
     *
     * @param delegateFor - Optional address of the delegator.
     * @returns The computed hash.
     *
     * Mainly:
     *  - No 'delegateFor': return txHash
     * - 'delegateFor' return txHash +  hash('delegateFor' address)
     *
     * @remarks
     * delegateFor is used to sign a transaction on behalf of another account.
     * In fact when the delegator sign the transaction, delegator will add the address
     * of who send the transaction to sign (in this case the 'delegateFor' address parameter)
     *
     * @example
     * A is transaction origin
     * B is the delegator
     * TX is the transaction
     *
     * A sends a TX (signed by A) to B to who add his signature to TX using delegateFor parameter (that is A address)
     * on signing hash of TX computation.
     *
     * Mathematically:
     *
     * ```
     * final_signature = concat_buffer(
     *      sign(TX.signingHash(), A.privateKey),
     *      sign(TX.signingHash(A.address), B.privateKey)
     * )
     * ```
     *
     * Where:
     *
     * ```
     * TX.signatureHash() = blake2b256(TX.encoded)
     * TX.signingHash(A.address) = blake2b256(
     *      concat(
     *              blake2b256(TX.encoded),
     *              A.address
     *             )
     * )
     * ```
     *
     * @throws{InvalidAddressError}
     * @param delegateFor - Address of the delegator
     * @returns Signing hash of the transaction
     */
    getSignatureHash(delegateFor?: string): Buffer;
    /**
     * Encode a transaction
     *
     * @returns The transaction encoded
     */
    get encoded(): Buffer;
    /**
     * Get transaction origin address from signature.
     *
     * @throws{TransactionNotSignedError}
     * @returns Transaction origin
     */
    get origin(): string;
    /**
     * Get transaction ID from signature.
     *
     * @throws{TransactionNotSignedError}
     * @returns Transaction ID
     */
    get id(): string;
    /**
     * Internal function to check if transaction is delegated or not.
     * This function is used to check directly the transaction body.
     * @private
     *
     * @param body Transaction body to check
     * @returns Weather the transaction is delegated or not
     */
    private _isDelegated;
    /**
     * Internal function to check if signature is valid or not.
     * This function is used to check directly the signature.
     * @private
     *
     * @param signature Signature to check
     * @returns Weather the signature is valid or not
     */
    private _isSignatureValid;
    /**
     * Encodes the reserved field to ensure it exists in every encoding.
     *
     * Due to the fact that reserved field is optional in TransactionBody,
     * BUT mandatory in RLPProfiler, we need to have it in every encoding.
     * Fot this reason this function is needed.
     * @private
     *
     * @returns Encoding of reserved field
     */
    private _encodeReservedField;
    /**
     * Make the RLP encoding of a transaction body.
     * @private
     *
     * @param body Body to encode
     * @param isSigned If transaction is signed or not
     * @returns RLP encoding of transaction body
     */
    private _lowLevelEncodeTransactionBodyWithRLP;
    /**
     * Private utility function to encode a transaction.
     * @private
     *
     * @param isSigned If transaction is signed or not (needed to determine if encoding with SIGNED_TRANSACTION_RLP or UNSIGNED_TRANSACTION_RLP)
     * @returns Encoding of transaction
     */
    private _encode;
    /**
     * utility function to check transaction body validity.
     *
     * @param body Transaction body to check
     */
    static isValidBody(body: TransactionBody): boolean;
}

/**
 * Sign a transaction with a given private key
 *
 * @throws{InvalidSecp256k1PrivateKeyError, TransactionAlreadySignedError, TransactionDelegationError}
 * @param transactionBody - The body of the transaction to sign
 * @param signerPrivateKey - Private key used to sign the transaction
 * @returns Signed transaction
 */
declare function sign$1(transactionBody: TransactionBody, signerPrivateKey: Buffer): Transaction;
/**
 * Sign a transaction with signer and delegator private keys
 *
 * @throws{InvalidSecp256k1PrivateKeyError, TransactionAlreadySignedError, TransactionDelegationError}
 * @param transactionBody - The body of the transaction to sign
 * @param signerPrivateKey - Signer private key (the origin)
 * @param delegatorPrivateKey - Delegate private key (the delegator)
 * @returns Signed transaction
 */
declare function signWithDelegator(transactionBody: TransactionBody, signerPrivateKey: Buffer, delegatorPrivateKey: Buffer): Transaction;

/**
 * Decode a raw transaction.
 * It can be signed or unsigned.
 *
 * @param rawTransaction - Raw transaction to decode
 * @param isSigned - If the transaction is signed or not
 * @returns Decoded transaction (signed or unsigned)
 */
declare function decode(rawTransaction: Buffer, isSigned: boolean): Transaction;

declare const TransactionHandler: {
    sign: typeof sign$1;
    signWithDelegator: typeof signWithDelegator;
    decode: typeof decode;
};

/**
 * Constant representing the zero address in hexadecimal format
 */
declare const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
/**
 * VTHO token address (energy.sol smart contract address)
 */
declare const VTHO_ADDRESS = "0x0000000000000000000000000000456e65726779";
/**
 * Parameters smart contract address (params.sol smart contract address)
 */
declare const PARAMS_ADDRESS = "0x0000000000000000000000000000506172616d73";
/**
 * Constant defining vechain mainnet information
 */
declare const MAINNET_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining vechain testnet information
 */
declare const TESTNET_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining vechain solo network information
 */
declare const SOLO_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining vechain mainnet and testnet network information
 */
declare const networkInfo: {
    mainnet: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
    testnet: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
    solo: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
};

/**
 * Represents the parameters required for deployment.
 * @interface DeployParams
 */
interface DeployParams {
    /**
     * An array of types associated with the deployment parameters.
     * @type {string[] | ParamType[]}
     */
    types: string[] | ParamType[];

    /**
     * An array of values corresponding to the deployment parameters.
     * @type {string[]}
     */
    values: string[];
}

/**
 * Builds a clause for deploying a smart contract.
 *
 * @param contractBytecode - The bytecode of the smart contract to be deployed.
 * @param deployParams - The parameters to pass to the smart contract constructor.
 *
 * @returns A clause for deploying a smart contract.
 */
declare function deployContract(contractBytecode: string, deployParams?: DeployParams): TransactionClause;
/**
 * Builds a clause for interacting with a smart contract function.
 *
 * @param contractAddress - The address of the smart contract.
 * @param functionFragment - The function fragment to interact with.
 * @param args - The input data for the function.
 *
 * @returns A clause for interacting with a smart contract function.
 *
 * @throws Will throw an error if an error occurs while encoding the function input.
 */
declare function functionInteraction(contractAddress: string, functionFragment: FunctionFragment, args: unknown[]): TransactionClause;
/**
 * Builds a clause for transferring VIP180 tokens.
 *
 * @param tokenAddress - The address of the VIP180 token.
 * @param recipientAddress - The address of the recipient.
 * @param amount - The amount of tokens to transfer in the decimals of the token.
 *                 For instance, a token with 18 decimals, 1 token would be 1000000000000000000 (i.e., 10 ** 18).
 *
 * @returns A clause for transferring VIP180 tokens.
 *
 * @throws Will throw an error if the amount is not an integer or if the encoding of the function input fails.
 */
declare function transferToken(tokenAddress: string, recipientAddress: string, amount: number | bigint | string): TransactionClause;
/**
 * Builds a clause for transferring VET.
 *
 * @param recipientAddress - The address of the recipient.
 * @param amount - The amount of VET to transfer in wei.
 * @returns A clause for transferring VET.
 *
 * @throws Will throw an error if the amount is not an integer.
 */
declare function transferVET(recipientAddress: string, amount: number | bigint | string): TransactionClause;
/**
 * Transfers a specified NFT (Non-Fungible Token) from one address to another.
 *
 * This function prepares a transaction clause for transferring an NFT, based on the ERC721 standard,
 * by invoking a smart contract's 'transferFrom' method.
 *
 * @param {string} contractAddress - The address of the NFT contract.
 * @param {string} senderAddress - The address of the current owner (sender) of the NFT.
 * @param {string} recipientAddress - The address of the new owner (recipient) of the NFT.
 * @param {string} tokenId - The unique identifier of the NFT to be transferred.
 * @returns {TransactionClause} - An object representing the transaction clause required for the transfer.
 *
 * @throws {InvalidDataTypeError, InvalidAbiDataToEncodeError}.
 * */
declare function transferNFT(contractAddress: string, senderAddress: string, recipientAddress: string, tokenId: string): TransactionClause;
/**
 * clauseBuilder provides methods for building clauses for interacting with smart contracts or deploying smart contracts.
 */
declare const clauseBuilder: {
    deployContract: typeof deployContract;
    functionInteraction: typeof functionInteraction;
    transferToken: typeof transferToken;
    transferVET: typeof transferVET;
    transferNFT: typeof transferNFT;
};

/**
 * Input to hash function.
 */
type HashInput = BytesLike$1;

type ReturnType = 'buffer' | 'hex';

/**
 * Computes the blake2b256 256-bit hash of the given data.
 * Returns the hash as a Buffer.
 *
 * @param data - The input data (either a Buffer or string) for which the hash needs to be computed.
 * @returns A Buffer containing the 256-bit blake2b256 hash of the provided data.
 */
declare function blake2b256(data: HashInput): Buffer;
/**
 * Computes the blake2b256 256-bit hash of the given data.
 * Returns the hash as a Buffer.
 *
 * @param data - The input data (either a Buffer or string) for which the hash needs to be computed.
 * @param returnType - The format in which to return the hash. Either 'buffer' or 'hex'.
 * @returns {Buffer} A Buffer containing the 256-bit blake2b256 hash of the provided data.
 */
declare function blake2b256(data: HashInput, returnType: 'buffer'): Buffer;
/**
 * Computes the blake2b256 256-bit hash of the given data.
 * Returns the hash as a hex string, prefixed with `0x`.
 *
 * @param data - The input data (either a Buffer or string) for which the hash needs to be computed.
 * @param returnType - The format in which to return the hash. Either 'hex' or 'buffer'.
 * @returns {string} A string representing the hexadecimal format of the 256-bit blake2b256 hash, prefixed with `0x`.
 */
declare function blake2b256(data: HashInput, returnType: 'hex'): string;

/**
 * Computes the sha256 hash of the given data.
 * Returns the hash as a Buffer.
 *
 * @param data - The input data (either a Buffer or string) for which the hash needs to be computed.
 * @returns A Buffer containing the 256-bit sha256 hash of the provided data.
 */
declare function sha256(data: HashInput): Buffer;
/**
 * Computes the sha256 hash of the given data.
 * Returns the hash as a Buffer.
 *
 * @param data - The input data (either a Buffer or string) for which the hash needs to be computed.
 * @param returnType - The format in which to return the hash. Either 'buffer' or 'hex'.
 * @returns {Buffer} A Buffer containing the 256-bit sha256 hash of the provided data.
 */
declare function sha256(data: HashInput, returnType: 'buffer'): Buffer;
/**
 * Computes the sha256 hash of the given data.
 * Returns the hash as a hex string, prefixed with `0x`.
 *
 * @param data - The input data (either a Buffer or string) for which the hash needs to be computed.
 * @param returnType - The format in which to return the hash. Either 'hex' or 'buffer'.
 * @returns {string} A string representing the hexadecimal format of the 256-bit sha256 hash, prefixed with `0x`.
 */
declare function sha256(data: HashInput, returnType: 'hex'): string;

/**
 * Computes the keccak256 hash of the given data.
 * Returns the hash as a Buffer.
 *
 * @param data - The input data (either a Buffer or string) for which the hash needs to be computed.
 * @returns A Buffer containing the 256-bit keccak256 hash of the provided data.
 */
declare function keccak256(data: HashInput): Buffer;
/**
 * Computes the keccak256 hash of the given data.
 * Returns the hash as a Buffer.
 *
 * @param data - The input data (either a Buffer or string) for which the hash needs to be computed.
 * @param returnType - The format in which to return the hash. Either 'buffer' or 'hex'.
 * @returns {Buffer} A Buffer containing the 256-bit keccak256 hash of the provided data.
 */
declare function keccak256(data: HashInput, returnType: 'buffer'): Buffer;
/**
 * Computes the keccak256 hash of the given data.
 * Returns the hash as a hex string, prefixed with `0x`.
 *
 * @param data - The input data (either a Buffer or string) for which the hash needs to be computed.
 * @param returnType - The format in which to return the hash. Either 'hex' or 'buffer'.
 * @returns {string} A string representing the hexadecimal format of the 256-bit keccak256 hash, prefixed with `0x`.
 */
declare function keccak256(data: HashInput, returnType: 'hex'): string;

/**
 * Represents a BIP32 hierarchical deterministic (HD) node.
 *
 * BIP32 HD nodes allow for the derivation of child nodes from a master node,
 * enabling the generation of a tree structure of key pairs from a single seed.
 */
interface IHDNode {
    /**
     * The public key associated with the HD node.
     */
    readonly publicKey: Buffer;

    /**
     * The private key associated with the HD node.
     *
     * Note: This can be `null` if the HD node is instantiated from only a public key.
     */
    readonly privateKey: Buffer | null;

    /**
     * The chain code associated with the HD node.
     *
     * The chain code is used in combination with the private key or public key to derive child keys.
     */
    readonly chainCode: Buffer;

    /**
     * The address associated with the HD node's public key.
     */
    readonly address: string;

    /**
     * Derives a child node from the current node using the given index.
     *
     * @param index - The child index to derive.
     * @returns The derived child HD node.
     */
    derive: (index: number) => IHDNode;

    /**
     * Derives a series of child nodes from the current node based on a path string.
     *
     * @param path - The derivation path string (e.g., "m/0'/0'/0'").
     * @returns The derived child HD node at the end of the path.
     */
    derivePath: (path: string) => IHDNode;
}

/**
 * Generates an HDNode instance using mnemonic words.
 *
 * @throws {InvalidHDNodeMnemonicsError, InvalidHDNodeDerivationPathError}
 * @param words - The mnemonic words.
 * @param path - The derivation path (default is VET_DERIVATION_PATH).
 * @returns An IHDNode instance derived from the given mnemonic.
 */
declare function fromMnemonic(words: string[], path?: string): IHDNode;
/**
 * Generates an HDNode instance using an extended public key.
 *
 * @throws{InvalidHDNodePublicKeyError, InvalidHDNodeChaincodeError}
 * @param publicKey - The extended public key.
 * @param chainCode - The associated chain code.
 * @returns An IHDNode instance derived from the given public key and chain code.
 */
declare function fromPublicKey(publicKey: Buffer, chainCode: Buffer): IHDNode;
/**
 * Generates an HDNode instance using an extended private key (xpriv).
 *
 * @throws{InvalidHDNodePrivateKeyError, InvalidHDNodeChaincodeError}
 * @param privateKey - The private key.
 * @param chainCode - The associated chain code.
 * @returns An IHDNode instance derived from the given private key and chain code.
 */
declare function fromPrivateKey(privateKey: Buffer, chainCode: Buffer): IHDNode;
declare const HDNode: {
    fromMnemonic: typeof fromMnemonic;
    fromPublicKey: typeof fromPublicKey;
    fromPrivateKey: typeof fromPrivateKey;
};

/**
 * Types of ciphers for keystore encryption
 */
type Cipher = 'aes-128-ctr' | 'aes-128-cbc' | 'aes-256-cbc';

/**
 * Scrypt parameters for keystore encryption
 */
interface ScryptParams {
    dklen: number;
    n: number;
    p: number;
    r: number;
    salt: Uint8Array | string;
}

/**
 * PBKDF2SHA256 parameters for keystore encryption
 */
interface PBKDF2SHA256Params {
    c: number;
    dklen: number;
    prf: 'hmac-sha256';
    salt: Uint8Array | string;
}

/**
 * Keystore type.
 * Output of encryption function.
 */
interface Keystore {
    crypto: {
        cipher: Cipher;
        ciphertext: string;
        cipherparams: {
            iv: string;
        };
        kdf: 'pbkdf2' | 'scrypt';
        kdfparams: ScryptParams | PBKDF2SHA256Params;
        mac: string;
    };
    id: string;
    version: 3;
    address: string;
}

/**
 * Keystore account type
 * Output of decryption function.
 */
interface KeystoreAccount {
    address: string;
    privateKey: string;
    mnemonic?: {
        path?: string;
        locale?: string;
        entropy: string;
    };
}

/**
 * Encrypts a given private key into a keystore format using the specified password.
 *
 * @param privateKey - The private key to be encrypted.
 * @param password - The password used for the encryption.
 * @returns A Promise that resolves to the encrypted keystore.
 */
declare function encrypt(privateKey: Buffer, password: string): Promise<Keystore>;
/**
 * Decrypts a keystore to obtain the private key using the given password.
 *
 * @throws{InvalidKeystoreError, InvalidKeystorePasswordError}
 * @param keystore - The keystore containing the encrypted private key.
 * @param password - The password used to decrypt the keystore.
 * @returns A Promise that resolves to the decrypted KeystoreAccount or rejects if the keystore or password is invalid.
 */
declare function decrypt(keystore: Keystore, password: string): Promise<KeystoreAccount>;
/**
 * Validates if the provided keystore adheres to the expected format and structure.
 *
 * @param keystore - The keystore to be validated.
 * @returns A boolean indicating whether the keystore is valid or not.
 */
declare function isValid(keystore: Keystore): boolean;
/**
 * Exports the keystore functions for encryption, decryption, and validation.
 */
declare const keystore: {
    encrypt: typeof encrypt;
    decrypt: typeof decrypt;
    isValid: typeof isValid;
};

/**
 * Type of the wordlist size.
 * Every 4 bytes produce 3 words.
 */
type WordlistSizeType = 12 | 15 | 18 | 21 | 24;

/**
 * Size of the mnemonic words in bytes.
 */
type WordListRandomGeneratorSizeInBytes = 16 | 20 | 24 | 28 | 32;

/**
 * Generate BIP39 mnemonic words
 * We can have 12, 15, 18, 21, 24 words
 *
 * @param wordlistSize - Wordlist size expected. Every 4 bytes produce 3 words.
 * @param randomGenerator - The optional random number generator to use.
 * @returns Mnemonic words
 */
declare function generate(wordlistSize?: WordlistSizeType, randomGenerator?: (numberOfBytes: WordListRandomGeneratorSizeInBytes) => Buffer): string[];
/**
 * Generate BIP39 mnemonic words
 * We can have 12, 15, 18, 21, 24 words
 *
 * @param wordlistSize - Wordlist size expected. Every 4 bytes produce 3 words.
 * @returns Mnemonic words
 */
declare function generate(wordlistSize?: WordlistSizeType): string[];
/**
 * Check if the given mnemonic words have valid checksum
 *
 * @param words Mnemonic words
 * @returns If mnemonic words are valid or not
 */
declare function validate(words: string[]): boolean;
/**
 * Derive private key at a specific index from mnemonic words according to BIP32. The default index is 0.
 * the derivation path is defined at https://github.com/satoshilabs/slips/blob/master/slip-0044.md
 *
 * @param words Mnemonic words
 * @param derivationPathFromCurrentNode Derivation path starting from the current HD node
 * @example `0` (default)
 * @example `0/2`
 * @example `0/2/4/6`
 * @returns Private key
 */
declare function derivePrivateKey(words: string[], derivationPathFromCurrentNode?: string): Buffer;
/**
 *
 * Derive address at a specific index from mnemonic words. The default index is 0.
 *
 * @param words Mnemonic words
 * @param derivationPathFromCurrentNode Derivation path starting from the current HD node
 * @example `0` (default)
 * @example `0/2`
 * @example `0/2/4/6`
 * @returns Address
 */
declare function deriveAddress(words: string[], derivationPathFromCurrentNode?: string): string;
declare const mnemonic: {
    generate: typeof generate;
    validate: typeof validate;
    derivePrivateKey: typeof derivePrivateKey;
    deriveAddress: typeof deriveAddress;
};

/**
 * Validate message hash
 * @param hash of message
 * @returns if message hash is valid or not
 */
declare function isValidMessageHash(hash: Buffer): boolean;
/**
 * Verify if private key is valid
 * @returns If private key is valid or not
 */
declare function isValidPrivateKey(key: Buffer): boolean;
/**
 * Generate private key using elliptic curve algorithm on the curve secp256k1
 * @param entropy - entropy function
 * @returns Private key generated
 */
declare function generatePrivateKey(entropy?: () => Buffer): Buffer;
/**
 * Derive public key from private key using elliptic curve algorithm on the curve secp256k1
 *
 * @throws{InvalidSecp256k1PrivateKeyError}
 * @param privateKey - private key to derive public key from
 * @returns Public key derived from private key
 */
declare function derivePublicKey(privateKey: Buffer): Buffer;
/**
 * sign a message using elliptic curve algorithm on the curve secp256k1
 *
 * @throws{InvalidSecp256k1PrivateKeyError, InvalidSecp256k1MessageHashError}
 * @param messageHash hash of message
 * @param privateKey serialized private key
 */
declare function sign(messageHash: Buffer, privateKey: Buffer): Buffer;
/**
 * Recovery signature to public key
 *
 * @throws{InvalidSecp256k1MessageHashError, InvalidSecp256k1SignatureError, InvalidSecp256k1SignatureRecoveryError}
 * @param messageHash hash of message
 * @param sig signature
 */
declare function recover(messageHash: Buffer, sig: Buffer): Buffer;
/**
 * Convert extended public key to array public key (compressed or uncompressed)
 *
 * @param extendedPublicKey extended public key
 * @param compact if public key should be compressed or not
 * @returns array public key
 */
declare function extendedPublicKeyToArray(extendedPublicKey: Buffer, compact: boolean): number[];
declare const secp256k1: {
    isValidMessageHash: typeof isValidMessageHash;
    isValidPrivateKey: typeof isValidPrivateKey;
    generatePrivateKey: typeof generatePrivateKey;
    derivePublicKey: typeof derivePublicKey;
    sign: typeof sign;
    recover: typeof recover;
    extendedPublicKeyToArray: typeof extendedPublicKeyToArray;
};

/**
 * Regular expression for validating in hexadecimal strings uppercase.
 */
declare const BLOOM_REGEX_UPPERCASE: RegExp;
/**
 * Regular expression for validating in hexadecimal strings lowercase.
 */
declare const BLOOM_REGEX_LOWERCASE: RegExp;

/**
 * Zero buffer
 * @internal
 *
 * @example ZERO_BUFFER(8) -> 0x00000000 , ... , ZERO_BUFFER(n) -> 0x0...0
 */
declare const ZERO_BUFFER: (size: number) => Buffer;
/**
 * Regular expression for validating hexadecimal strings.
 * Allows optional "0x" prefix and validates both lower and uppercase hex characters.
 */
declare const HEX_REGEX_OPTIONAL_PREFIX: RegExp;
/**
 * Regular expression for validating hexadecimal strings. Must have "0x" prefix.
 */
declare const HEX_REGEX: RegExp;
/**
 * Regular expression for validating hexadecimal addresses. Must have "0x" prefix. Must be 40 characters long.
 */
declare const HEX_ADDRESS_REGEX: RegExp;
/**
 * Regular expression for validating base 10 integer number format strings.
 */
declare const DECIMAL_INTEGER_REGEX: RegExp;
/**
 * Regular expression for validating base 10 numeric number format strings.
 * Allows optional "-" prefix and validates both integer and floating point numbers.
 * Also allows for numbers with no leading digits (i.e. ".123", which is equivalent to "0.123").
 */
declare const NUMERIC_REGEX: RegExp;
/**
 * Default length of thor id hex string.
 * Thor id is a 64 characters long hexadecimal string.
 * This is used to validate thor id strings (block ids, transaction ids, ...).
 */
declare const THOR_ID_LENGTH = 64;

/**
 * Default VET derivation path.
 *
 * See https://github.com/satoshilabs/slips/blob/master/slip-0044.md for more info.
 */
declare const VET_DERIVATION_PATH = "m/44'/818'/0'/0";
/**
 * Prefix for extended public key
 */
declare const X_PUB_PREFIX: Buffer;
/**
 * Prefix for extended private key
 */
declare const X_PRIV_PREFIX: Buffer;

/**
 * Keystore Scrypt params
 */
declare const SCRYPT_PARAMS: {
    N: number;
    r: number;
    p: number;
};

/**
 * Mnemonic wordlist size
 */
declare const MNEMONIC_WORDLIST_ALLOWED_SIZES: WordlistSizeType[];

/**
 * Biggest value of private key
 * @internal
 */
declare const PRIVATE_KEY_MAX_VALUE: Buffer;

/**
 * Transaction gas constants
 */
declare const TRANSACTIONS_GAS_CONSTANTS: {
    /**
     * Default gas for a transaction
     * @internal
     */
    TX_GAS: number;
    /**
     * Default gas for a clause
     * @internal
     */
    CLAUSE_GAS: number;
    /**
     * Default gas for a contract creation clause
     * @internal
     */
    CLAUSE_GAS_CONTRACT_CREATION: number;
    /**
     * Zero gas data
     * @internal
     */
    ZERO_GAS_DATA: number;
    /**
     * Non-zero gas data
     * @internal
     */
    NON_ZERO_GAS_DATA: number;
};
/**
 * Kind for transaction features
 * @internal
 */
declare const TRANSACTION_FEATURES_KIND: {
    name: string;
    kind: NumericKind;
};
/**
 * Kind for transaction signature
 * @internal
 */
declare const TRANSACTION_SIGNATURE_KIND: {
    name: string;
    kind: BufferKind;
};
/**
 * RLP profiler for simple unsigned transactions
 * @internal
 */
declare const UNSIGNED_TRANSACTION_RLP: {
    readonly profile: RLPProfile;
    encodeObject(data: RLPValidObject): Buffer;
    decodeObject(encodedData: Buffer): RLPValueType;
};
/**
 * RLP profiler for simple signed transactions
 * @internal
 */
declare const SIGNED_TRANSACTION_RLP: {
    readonly profile: RLPProfile;
    encodeObject(data: RLPValidObject): Buffer;
    decodeObject(encodedData: Buffer): RLPValueType;
};
/**
 * Signature length
 * @internal
 */
declare const SIGNATURE_LENGTH = 65;
/**
 * Block ref field length
 * @internal
 */
declare const BLOCK_REF_LENGTH = 8;

/**
 * ABI of the Params built-in contract.
 *
 * @link see [params.sol](https://docs.vechain.org/developer-resources/built-in-contracts#params-sol)
 */
declare const PARAMS_ABI: string;
/**
 * ABI of the VIP180 token standard.
 *
 * @see [VIP 180](https://github.com/vechain/VIPs/blob/master/vips/VIP-180.md)
 */
declare const VIP180_ABI: string;
declare const ERC721_ABI: string;

declare const bloomUtils: {
    isBloom: (bloom: string) => boolean;
    isInBloom: (bloom: string, k: number, data: string) => boolean;
    isAddressInBloom: (bloom: string, k: number, addressToCheck: string) => boolean;
};

/**
 * Confirugation for hex values.
 * In particular, whether or not to include the `0x` prefix.
 */
interface HexConfig {
    withPrefix: boolean;
}

/**
 * Pads a hexadecimal string to a fixed length by adding zeros to the left.
 *
 * @param {string} hexString - The original hexadecimal string to pad. It can optionally start with '0x'.
 * @param {number} [hexTargetLength=64] - The desired length in characters for the output string. Defaults to vechain data length of 64 characters if not specified. If the value is less than or equal to str.length, then str is returned as-is.
 * @returns {string} - The padded hexadecimal string, starting with '0x' and with length matching the specified number of characters.
 *
 * @example
 * // returns '0x000000000000000000000000000000000000000000000000000000000000001a'
 * padHexString('1a', 64);
 */
declare function padHexString(hexString: string, hexTargetLength?: number): string;
declare const dataUtils: {
    toHexString: (data: string | Uint8Array, config?: HexConfig) => string;
    isHexString: (data: string, checkPrefix?: boolean) => boolean;
    padHexString: typeof padHexString;
    removePrefix: (hex: string) => string;
    isDecimalString: (data: string) => boolean;
    isNumeric: (value: string) => boolean;
    isThorId: (data: string, checkPrefix?: boolean) => boolean;
    encodeBytes32String: (value: string, zeroPadding?: 'left' | 'right') => string;
    decodeBytes32String: (value: string) => string;
    generateRandomHexOfLength: (stringLength: number) => string;
};

/**
 * Checks if derivation path is valid
 *
 * @param derivationPath - Derivation path to check
 * @returns True if derivation path is valid, false otherwise
 */
declare function isDerivationPathValid(derivationPath: string): boolean;

/**
 * Convert an Uint8Array to a padded hexadecimal representation long the specified number of bytes.
 *
 * @param {Uint8Array} buffer - The Uint8Array to be represented as hexadecimal string.
 * @param {number} [bytes=0] - The number of bytes the resulting hexadecimal representation should be padded to.
 * @return {string} - The padded hexadecimal representation of the buffer.
 */
declare function ofBuffer(buffer: Buffer$1 | Uint8Array, bytes?: number): string;
/**
 * Helper class for encoding hexadecimal values.
 */
declare const Hex: {
    /**
     * Generate a hexadecimal representation from the given input data.
     * This method calls
     * * {@link ofBigInt} if `n` type is `bigint`;
     * * {@link ofNumber} if `n` type is `number`;
     * * {@link ofString} if `n` type is `string`;
     * * {@link ofBuffer} if `n` is an instance of {@link Uint8Array}.
     *
     * **Note:** the returned string is not prefixed with `0x`,
     * see {@link Hex.of0x} to make a hexadecimal representation prefixed with `0x`.
     *
     * @param {bigint | Uint8Array | number | string} n - The input data to be represented.
     * @param {number} [bytes=0] - If not `0` by default, the hexadecimal representation encodes at least {number}  bytes.
     * @returns {Uint8Array} - The resulting hexadecimal representation,
     * it is guaranteed to be even characters long.
     */
    of: (n: bigint | number | string | Uint8Array, bytes?: number) => string;
    /**
     * Generate a hexadecimal representation from the given input data prefixed with `0x`.
     *
     * **Note:** this method calls {@link Hex.of} to generate the hexadecimal representation of n,
     * then it prefixes the result with `0x`.
     *
     * @param {bigint | Uint8Array | number | string} n - The input data to be represented.
     * @param {number} [bytes=0] - If not `0` by default, the hexadecimal representation encodes at least {number}  bytes.
     * @returns {Uint8Array} - The resulting hexadecimal representation,
     * it is guaranteed to be even characters long.
     */
    of0x: (n: bigint | Uint8Array | number | string, bytes?: number) => string;
};

/**
 * Calculates intrinsic gas that a tx costs with the given set of clauses.
 *
 * @note see the following link for more details: https://docs.vechain.org/core-concepts/transactions/transaction-calculation
 *
 * @throws{InvalidDataTypeError}
 * @param clauses - Transaction clauses
 * @returns Intrinsic gas of a set of clauses
 */
declare function intrinsicGas(clauses: TransactionClause[]): number;
declare const TransactionUtils: {
    intrinsicGas: typeof intrinsicGas;
};

/**
 * BigNumberish type
 * @typedef {string | number | bigint} BigNumberish
 */
type BigNumberish = string | number | bigint;

/**
 * The supported units of Ether currency which are supported by VechainThor too.
 *
 * wei - The smallest unit of currency. 1 wei is equal to 10^-18 VET.
 * kewi - 1 kewi is equal to 10^3 wei.
 * mwei - 1 mwei is equal to 10^6 wei.
 * gwei - 1 gwei is equal to 10^9 wei.
 * szabo - 1 szabo is equal to 10^12 wei.
 * finney - 1 finney is equal to 10^15 wei.
 * ether - 1 ether is equal to 10^18 wei.
 */
type WEI_UNITS =
    | 'wei'
    | 'kwei'
    | 'mwei'
    | 'gwei'
    | 'szabo'
    | 'finney'
    | 'ether';

declare const unitsUtils: {
    parseUnits: (value: string, decimals: WEI_UNITS | number | bigint) => bigint;
    formatUnits: (value: BigNumberish, decimals: WEI_UNITS | number | bigint) => string;
    parseVET: (value: string) => bigint;
    formatVET: (value: BigNumberish) => string;
};

/**
 * A utility object for revision-related utility operations.
 */
declare const revisionUtils: {
    isRevisionBlock: (revision: string | number) => boolean;
    isRevisionAccount: (revision: string | number) => boolean;
};

/**
 * Assert if address is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param address - Address to assert
 */
declare function assertIsAddress(methodName: string, address: string): void;

/**
 * Assert if a given revision is valid.
 * A valid revision is a string representing a block number or block id.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param revision - Revision to assert
 */
declare function assertIsRevisionForBlock(methodName: string, revision?: string | number): void;
/**
 * Assert if a given revision is valid.
 * A valid revision is a string representing a block number or block id.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param revision - Revision to assert
 */
declare function assertIsRevisionForAccount(methodName: string, revision?: string | number): void;

/**
 * Asserts that the return type of hash is valid.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param returnType - The return type of the hash function
 */
declare function assertIsValidReturnType(methodName: string, returnType: ReturnType): void;

/**
 * Asserts that the derivation path is valid.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param path - The derivation path to validate.
 */
declare function assertIsValidHdNodeDerivationPath(methodName: string, path: string): void;
/**
 * Asserts that the chain code is valid.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param chainCode - The chain code to validate.
 */
declare function assertIsValidHdNodeChainCode(methodName: string, chainCode: Buffer): void;

/**
 * Assert if private key is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param methodName - The name of the method calling this assertion.
 * @param privateKey - Private key to assert
 * @param isValidPrivateKeyFunction - Function to assert private key
 */
declare function assertIsValidPrivateKey(methodName: string, privateKey: Buffer, isValidPrivateKeyFunction: (privateKey: Buffer) => boolean): void;
/**
 * Assert if message hash is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param msgHash - Message hash to assert
 * @param isValidMessageHashFunction - Function to assert message hash
 */
declare function assertIsValidSecp256k1MessageHash(methodName: string, msgHash: Buffer, isValidMessageHashFunction: (messageHash: Buffer) => boolean): void;

/**
 * Assert if transaction ID is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param transactionId - Transaction ID to assert
 */
declare function assertValidTransactionID(methodName: string, transactionId: string): void;
/**
 * Assert if transaction head is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param head - Transaction head to assert
 */
declare function assertValidTransactionHead(methodName: string, head?: string): void;
/**
 * Asserts that the given transaction is signed.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param tx - The transaction to check.
 */
declare function assertIsSignedTransaction(methodName: string, tx: Transaction): void;
/**
 * Assert if a private key used to sign a transaction is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param privateKey - Private key to assert
 * @param isValidPrivateKeyFunction - Function to assert private key
 * @param role - Role of the private key (e.g., delegator, or signer)
 */
declare function assertIsValidTransactionSigningPrivateKey(methodName: string, privateKey: Buffer, isValidPrivateKeyFunction: (privateKey: Buffer) => boolean, role?: string): void;
/**
 * Assert if transaction is not signed and cannot get field (e.g. delegator, origin, or id)
 *
 * @param methodName - The name of the method calling this assertion.
 * @param transaction - Transaction to assert
 * @param fieldToGet - Field to get (e.g. delegator, origin, or id)
 */
declare function assertCantGetFieldOnUnsignedTransaction(methodName: string, transaction: Transaction, fieldToGet: string): void;

/**
 * Asserts that the data is a buffer.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param bufferToCheck - The bufferToCheck to validate.
 * @param context - Descriptive context for error messages.
 *
 * @throws{InvalidRLPError}
 */
declare function assertIsValidBuffer(methodName: string, bufferToCheck: Buffer | RLPInput, context: string): void;
/**
 * Asserts that the data is an array.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param arrayToCheck - The arrayToCheck to validate.
 * @param context - Descriptive context for error messages.
 *
 * @throws{InvalidRLPError}
 */
declare function assertIsArray<ArrayType>(methodName: string, arrayToCheck: ArrayType, context: string): void;

type core_ArrayKind = ArrayKind;
declare const core_BLOCK_REF_LENGTH: typeof BLOCK_REF_LENGTH;
declare const core_BLOOM_REGEX_LOWERCASE: typeof BLOOM_REGEX_LOWERCASE;
declare const core_BLOOM_REGEX_UPPERCASE: typeof BLOOM_REGEX_UPPERCASE;
type core_BigNumberish = BigNumberish;
type core_BufferOutput = BufferOutput;
type core_BytesLike = BytesLike;
type core_Certificate = Certificate;
type core_Cipher = Cipher;
declare const core_DECIMAL_INTEGER_REGEX: typeof DECIMAL_INTEGER_REGEX;
type core_DataOutput = DataOutput;
type core_DeployParams = DeployParams;
declare const core_ERC721_ABI: typeof ERC721_ABI;
type core_FormatType = FormatType;
type core_FunctionFragment = FunctionFragment;
declare const core_HDNode: typeof HDNode;
declare const core_HEX_ADDRESS_REGEX: typeof HEX_ADDRESS_REGEX;
declare const core_HEX_REGEX: typeof HEX_REGEX;
declare const core_HEX_REGEX_OPTIONAL_PREFIX: typeof HEX_REGEX_OPTIONAL_PREFIX;
type core_HashInput = HashInput;
declare const core_Hex: typeof Hex;
type core_HexConfig = HexConfig;
type core_IHDNode = IHDNode;
type core_Interface = Interface;
type core_InterfaceAbi = InterfaceAbi;
type core_Keystore = Keystore;
type core_KeystoreAccount = KeystoreAccount;
type core_Log = Log;
declare const core_MAINNET_NETWORK: typeof MAINNET_NETWORK;
declare const core_MNEMONIC_WORDLIST_ALLOWED_SIZES: typeof MNEMONIC_WORDLIST_ALLOWED_SIZES;
declare const core_NUMERIC_REGEX: typeof NUMERIC_REGEX;
declare const core_PARAMS_ABI: typeof PARAMS_ABI;
declare const core_PARAMS_ADDRESS: typeof PARAMS_ADDRESS;
type core_PBKDF2SHA256Params = PBKDF2SHA256Params;
declare const core_PRIVATE_KEY_MAX_VALUE: typeof PRIVATE_KEY_MAX_VALUE;
type core_ParamType = ParamType;
declare const core_RLP: typeof RLP;
declare const core_RLPBase: typeof RLPBase;
type core_RLPInput = RLPInput;
type core_RLPOutput = RLPOutput;
type core_RLPProfile = RLPProfile;
declare const core_RLPProfiles: typeof RLPProfiles;
type core_RLPValidObject = RLPValidObject;
type core_RLPValueType = RLPValueType;
type core_Result = Result;
type core_ReturnType = ReturnType;
declare const core_SCRYPT_PARAMS: typeof SCRYPT_PARAMS;
declare const core_SIGNATURE_LENGTH: typeof SIGNATURE_LENGTH;
declare const core_SIGNED_TRANSACTION_RLP: typeof SIGNED_TRANSACTION_RLP;
declare const core_SOLO_NETWORK: typeof SOLO_NETWORK;
type core_ScalarKind = ScalarKind;
declare const core_ScalarKind: typeof ScalarKind;
type core_ScryptParams = ScryptParams;
type core_StructKind = StructKind;
declare const core_TESTNET_NETWORK: typeof TESTNET_NETWORK;
declare const core_THOR_ID_LENGTH: typeof THOR_ID_LENGTH;
declare const core_TRANSACTIONS_GAS_CONSTANTS: typeof TRANSACTIONS_GAS_CONSTANTS;
declare const core_TRANSACTION_FEATURES_KIND: typeof TRANSACTION_FEATURES_KIND;
declare const core_TRANSACTION_SIGNATURE_KIND: typeof TRANSACTION_SIGNATURE_KIND;
type core_Transaction = Transaction;
declare const core_Transaction: typeof Transaction;
type core_TransactionBody = TransactionBody;
type core_TransactionClause = TransactionClause;
declare const core_TransactionHandler: typeof TransactionHandler;
declare const core_TransactionUtils: typeof TransactionUtils;
declare const core_UNSIGNED_TRANSACTION_RLP: typeof UNSIGNED_TRANSACTION_RLP;
declare const core_VET_DERIVATION_PATH: typeof VET_DERIVATION_PATH;
declare const core_VIP180_ABI: typeof VIP180_ABI;
declare const core_VTHO_ADDRESS: typeof VTHO_ADDRESS;
type core_WEI_UNITS = WEI_UNITS;
type core_WordListRandomGeneratorSizeInBytes = WordListRandomGeneratorSizeInBytes;
type core_WordlistSizeType = WordlistSizeType;
declare const core_X_PRIV_PREFIX: typeof X_PRIV_PREFIX;
declare const core_X_PUB_PREFIX: typeof X_PUB_PREFIX;
declare const core_ZERO_ADDRESS: typeof ZERO_ADDRESS;
declare const core_ZERO_BUFFER: typeof ZERO_BUFFER;
declare const core_abi: typeof abi;
declare const core_addressUtils: typeof addressUtils;
declare const core_assertCantGetFieldOnUnsignedTransaction: typeof assertCantGetFieldOnUnsignedTransaction;
declare const core_assertCompactFixedHexBlobBuffer: typeof assertCompactFixedHexBlobBuffer;
declare const core_assertFixedHexBlobKindBuffer: typeof assertFixedHexBlobKindBuffer;
declare const core_assertFixedHexBlobKindData: typeof assertFixedHexBlobKindData;
declare const core_assertIsAddress: typeof assertIsAddress;
declare const core_assertIsArray: typeof assertIsArray;
declare const core_assertIsRevisionForAccount: typeof assertIsRevisionForAccount;
declare const core_assertIsRevisionForBlock: typeof assertIsRevisionForBlock;
declare const core_assertIsSignedTransaction: typeof assertIsSignedTransaction;
declare const core_assertIsValidBuffer: typeof assertIsValidBuffer;
declare const core_assertIsValidHdNodeChainCode: typeof assertIsValidHdNodeChainCode;
declare const core_assertIsValidHdNodeDerivationPath: typeof assertIsValidHdNodeDerivationPath;
declare const core_assertIsValidPrivateKey: typeof assertIsValidPrivateKey;
declare const core_assertIsValidReturnType: typeof assertIsValidReturnType;
declare const core_assertIsValidSecp256k1MessageHash: typeof assertIsValidSecp256k1MessageHash;
declare const core_assertIsValidTransactionSigningPrivateKey: typeof assertIsValidTransactionSigningPrivateKey;
declare const core_assertValidHexBlobKindBuffer: typeof assertValidHexBlobKindBuffer;
declare const core_assertValidHexBlobKindData: typeof assertValidHexBlobKindData;
declare const core_assertValidNumericKindBuffer: typeof assertValidNumericKindBuffer;
declare const core_assertValidTransactionHead: typeof assertValidTransactionHead;
declare const core_assertValidTransactionID: typeof assertValidTransactionID;
declare const core_blake2b256: typeof blake2b256;
declare const core_bloom: typeof bloom;
declare const core_bloomUtils: typeof bloomUtils;
declare const core_certificate: typeof certificate;
declare const core_clauseBuilder: typeof clauseBuilder;
declare const core_coder: typeof coder;
declare const core_dataUtils: typeof dataUtils;
declare const core_decodeBufferToHexWithLeadingZeros: typeof decodeBufferToHexWithLeadingZeros;
declare const core_decodeBufferToNumberOrHex: typeof decodeBufferToNumberOrHex;
declare const core_encodeBigIntToBuffer: typeof encodeBigIntToBuffer;
declare const core_encodeCompactFixedHexBlob: typeof encodeCompactFixedHexBlob;
declare const core_fragment: typeof fragment;
declare const core_isDerivationPathValid: typeof isDerivationPathValid;
declare const core_keccak256: typeof keccak256;
declare const core_keystore: typeof keystore;
declare const core_mnemonic: typeof mnemonic;
declare const core_networkInfo: typeof networkInfo;
declare const core_ofBuffer: typeof ofBuffer;
declare const core_revisionUtils: typeof revisionUtils;
declare const core_secp256k1: typeof secp256k1;
declare const core_sha256: typeof sha256;
declare const core_unitsUtils: typeof unitsUtils;
declare const core_validateNumericKindData: typeof validateNumericKindData;
declare namespace core {
  export { type core_ArrayKind as ArrayKind, core_BLOCK_REF_LENGTH as BLOCK_REF_LENGTH, core_BLOOM_REGEX_LOWERCASE as BLOOM_REGEX_LOWERCASE, core_BLOOM_REGEX_UPPERCASE as BLOOM_REGEX_UPPERCASE, type core_BigNumberish as BigNumberish, type core_BufferOutput as BufferOutput, type core_BytesLike as BytesLike, type core_Certificate as Certificate, type core_Cipher as Cipher, core_DECIMAL_INTEGER_REGEX as DECIMAL_INTEGER_REGEX, type core_DataOutput as DataOutput, type core_DeployParams as DeployParams, core_ERC721_ABI as ERC721_ABI, type core_FormatType as FormatType, type core_FunctionFragment as FunctionFragment, core_HDNode as HDNode, core_HEX_ADDRESS_REGEX as HEX_ADDRESS_REGEX, core_HEX_REGEX as HEX_REGEX, core_HEX_REGEX_OPTIONAL_PREFIX as HEX_REGEX_OPTIONAL_PREFIX, type core_HashInput as HashInput, core_Hex as Hex, type core_HexConfig as HexConfig, type core_IHDNode as IHDNode, type core_Interface as Interface, type core_InterfaceAbi as InterfaceAbi, type core_Keystore as Keystore, type core_KeystoreAccount as KeystoreAccount, type core_Log as Log, core_MAINNET_NETWORK as MAINNET_NETWORK, core_MNEMONIC_WORDLIST_ALLOWED_SIZES as MNEMONIC_WORDLIST_ALLOWED_SIZES, core_NUMERIC_REGEX as NUMERIC_REGEX, core_PARAMS_ABI as PARAMS_ABI, core_PARAMS_ADDRESS as PARAMS_ADDRESS, type core_PBKDF2SHA256Params as PBKDF2SHA256Params, core_PRIVATE_KEY_MAX_VALUE as PRIVATE_KEY_MAX_VALUE, type core_ParamType as ParamType, core_RLP as RLP, core_RLPBase as RLPBase, type core_RLPInput as RLPInput, type core_RLPOutput as RLPOutput, type core_RLPProfile as RLPProfile, core_RLPProfiles as RLPProfiles, type core_RLPValidObject as RLPValidObject, type core_RLPValueType as RLPValueType, type core_Result as Result, type core_ReturnType as ReturnType, core_SCRYPT_PARAMS as SCRYPT_PARAMS, core_SIGNATURE_LENGTH as SIGNATURE_LENGTH, core_SIGNED_TRANSACTION_RLP as SIGNED_TRANSACTION_RLP, core_SOLO_NETWORK as SOLO_NETWORK, core_ScalarKind as ScalarKind, type core_ScryptParams as ScryptParams, type core_StructKind as StructKind, core_TESTNET_NETWORK as TESTNET_NETWORK, core_THOR_ID_LENGTH as THOR_ID_LENGTH, core_TRANSACTIONS_GAS_CONSTANTS as TRANSACTIONS_GAS_CONSTANTS, core_TRANSACTION_FEATURES_KIND as TRANSACTION_FEATURES_KIND, core_TRANSACTION_SIGNATURE_KIND as TRANSACTION_SIGNATURE_KIND, core_Transaction as Transaction, type core_TransactionBody as TransactionBody, type core_TransactionClause as TransactionClause, core_TransactionHandler as TransactionHandler, core_TransactionUtils as TransactionUtils, core_UNSIGNED_TRANSACTION_RLP as UNSIGNED_TRANSACTION_RLP, core_VET_DERIVATION_PATH as VET_DERIVATION_PATH, core_VIP180_ABI as VIP180_ABI, core_VTHO_ADDRESS as VTHO_ADDRESS, type core_WEI_UNITS as WEI_UNITS, type core_WordListRandomGeneratorSizeInBytes as WordListRandomGeneratorSizeInBytes, type core_WordlistSizeType as WordlistSizeType, core_X_PRIV_PREFIX as X_PRIV_PREFIX, core_X_PUB_PREFIX as X_PUB_PREFIX, core_ZERO_ADDRESS as ZERO_ADDRESS, core_ZERO_BUFFER as ZERO_BUFFER, core_abi as abi, core_addressUtils as addressUtils, core_assertCantGetFieldOnUnsignedTransaction as assertCantGetFieldOnUnsignedTransaction, core_assertCompactFixedHexBlobBuffer as assertCompactFixedHexBlobBuffer, core_assertFixedHexBlobKindBuffer as assertFixedHexBlobKindBuffer, core_assertFixedHexBlobKindData as assertFixedHexBlobKindData, core_assertIsAddress as assertIsAddress, core_assertIsArray as assertIsArray, core_assertIsRevisionForAccount as assertIsRevisionForAccount, core_assertIsRevisionForBlock as assertIsRevisionForBlock, core_assertIsSignedTransaction as assertIsSignedTransaction, core_assertIsValidBuffer as assertIsValidBuffer, core_assertIsValidHdNodeChainCode as assertIsValidHdNodeChainCode, core_assertIsValidHdNodeDerivationPath as assertIsValidHdNodeDerivationPath, core_assertIsValidPrivateKey as assertIsValidPrivateKey, core_assertIsValidReturnType as assertIsValidReturnType, core_assertIsValidSecp256k1MessageHash as assertIsValidSecp256k1MessageHash, core_assertIsValidTransactionSigningPrivateKey as assertIsValidTransactionSigningPrivateKey, core_assertValidHexBlobKindBuffer as assertValidHexBlobKindBuffer, core_assertValidHexBlobKindData as assertValidHexBlobKindData, core_assertValidNumericKindBuffer as assertValidNumericKindBuffer, core_assertValidTransactionHead as assertValidTransactionHead, core_assertValidTransactionID as assertValidTransactionID, core_blake2b256 as blake2b256, core_bloom as bloom, core_bloomUtils as bloomUtils, core_certificate as certificate, core_clauseBuilder as clauseBuilder, core_coder as coder, core_dataUtils as dataUtils, core_decodeBufferToHexWithLeadingZeros as decodeBufferToHexWithLeadingZeros, core_decodeBufferToNumberOrHex as decodeBufferToNumberOrHex, core_encodeBigIntToBuffer as encodeBigIntToBuffer, core_encodeCompactFixedHexBlob as encodeCompactFixedHexBlob, core_fragment as fragment, core_isDerivationPathValid as isDerivationPathValid, core_keccak256 as keccak256, core_keystore as keystore, core_mnemonic as mnemonic, core_networkInfo as networkInfo, core_ofBuffer as ofBuffer, core_revisionUtils as revisionUtils, core_secp256k1 as secp256k1, core_sha256 as sha256, core_unitsUtils as unitsUtils, core_validateNumericKindData as validateNumericKindData, ethers as vechain_sdk_core_ethers };
}

export { type ArrayKind, BLOCK_REF_LENGTH, BLOOM_REGEX_LOWERCASE, BLOOM_REGEX_UPPERCASE, type BigNumberish, type BufferOutput, type BytesLike, type Certificate, type Cipher, DECIMAL_INTEGER_REGEX, type DataOutput, type DeployParams, ERC721_ABI, type FormatType, type FunctionFragment, HDNode, HEX_ADDRESS_REGEX, HEX_REGEX, HEX_REGEX_OPTIONAL_PREFIX, type HashInput, Hex, type HexConfig, type IHDNode, type Interface, type InterfaceAbi, type Keystore, type KeystoreAccount, type Log, MAINNET_NETWORK, MNEMONIC_WORDLIST_ALLOWED_SIZES, NUMERIC_REGEX, PARAMS_ABI, PARAMS_ADDRESS, type PBKDF2SHA256Params, PRIVATE_KEY_MAX_VALUE, type ParamType, RLP, RLPBase, type RLPInput, type RLPOutput, type RLPProfile, RLPProfiles, type RLPValidObject, type RLPValueType, type Result, type ReturnType, SCRYPT_PARAMS, SIGNATURE_LENGTH, SIGNED_TRANSACTION_RLP, SOLO_NETWORK, ScalarKind, type ScryptParams, type StructKind, TESTNET_NETWORK, THOR_ID_LENGTH, TRANSACTIONS_GAS_CONSTANTS, TRANSACTION_FEATURES_KIND, TRANSACTION_SIGNATURE_KIND, Transaction, type TransactionBody, type TransactionClause, TransactionHandler, TransactionUtils, UNSIGNED_TRANSACTION_RLP, VET_DERIVATION_PATH, VIP180_ABI, VTHO_ADDRESS, type WEI_UNITS, type WordListRandomGeneratorSizeInBytes, type WordlistSizeType, X_PRIV_PREFIX, X_PUB_PREFIX, ZERO_ADDRESS, ZERO_BUFFER, abi, addressUtils, assertCantGetFieldOnUnsignedTransaction, assertCompactFixedHexBlobBuffer, assertFixedHexBlobKindBuffer, assertFixedHexBlobKindData, assertIsAddress, assertIsArray, assertIsRevisionForAccount, assertIsRevisionForBlock, assertIsSignedTransaction, assertIsValidBuffer, assertIsValidHdNodeChainCode, assertIsValidHdNodeDerivationPath, assertIsValidPrivateKey, assertIsValidReturnType, assertIsValidSecp256k1MessageHash, assertIsValidTransactionSigningPrivateKey, assertValidHexBlobKindBuffer, assertValidHexBlobKindData, assertValidNumericKindBuffer, assertValidTransactionHead, assertValidTransactionID, blake2b256, bloom, bloomUtils, certificate, clauseBuilder, coder, core, dataUtils, decodeBufferToHexWithLeadingZeros, decodeBufferToNumberOrHex, encodeBigIntToBuffer, encodeCompactFixedHexBlob, fragment, isDerivationPathValid, keccak256, keystore, mnemonic, networkInfo, ofBuffer, revisionUtils, secp256k1, sha256, unitsUtils, validateNumericKindData };
